@using AnimatedDiagrams.Models
@using AnimatedDiagrams.PathGeometry
@using AnimatedDiagrams.Services
@inject PathEditorState Editor
@inject SettingsService SettingsSvc
@inject PensService PensService

<div class="canvas-wrapper" tabindex="0" @ref="_canvasWrapper" autofocus @onwheel="OnWheel"
    @onpointerdown="PointerDown" @onpointerdown:preventDefault
    @onpointermove="PointerMove" @onpointermove:preventDefault
    @onpointerup="PointerUp" @onpointerup:preventDefault
    style="background:@CanvasBgColor">
    <div class="canvas-toolbar">
    
    <button class="app-btn" 
        @onclick="OnToggleModeClick" @onpointerdown:stopPropagation @onpointerup:stopPropagation @onmousedown:stopPropagation
        title="Toggle between modes: drawing (keyboard shortcut: D) and select (keyboard shortcut: S)"
        >Mode: @(Editor.Mode == EditorMode.Drawing ? "Draw" : Editor.Mode == EditorMode.Select ? "Select" : "Animation")</button>
    <button class="app-btn" @onclick="Undo" @onpointerdown:stopPropagation @onpointerup:stopPropagation @onmousedown:stopPropagation disabled="!UndoRedo.CanUndo">Undo</button>
    <button class="app-btn" @onclick="Redo" @onpointerdown:stopPropagation @onpointerup:stopPropagation @onmousedown:stopPropagation disabled="!UndoRedo.CanRedo">Redo</button>
    <button class="app-btn" @onclick="DeleteSelectedPaths" @onpointerdown:stopPropagation @onpointerup:stopPropagation @onmousedown:stopPropagation disabled="@(Editor.SelectedItems.Count == 0)" title="Delete selected paths">Delete</button>
    <button class="app-btn" @onclick="DuplicateSelectedPaths" @onpointerdown:stopPropagation @onpointerup:stopPropagation @onmousedown:stopPropagation disabled="@(Editor.SelectedItems.Count == 0)" title="Duplicate selected paths">Duplicate</button>
    
        <span>Zoom: @Editor.Zoom.ToString("0.00")</span>
    @if (Editor.Mode == EditorMode.Drawing && PensService.ActivePen != null)
        {
            <span class="active-pen-indicator" style="margin-left:16px;display:inline-flex;align-items:center;gap:6px;">
                <span title="Active Pen" style="font-weight:bold;color:#0097a7;background:#e0f7fa;padding:2px 8px;border-radius:4px;">
                    @PensService.ActivePen.Name
                </span>
                <svg width="48" height="16" style="vertical-align:middle;">
                    <line x1="4" y1="8" x2="44" y2="8" stroke="@PensService.ActivePen.Stroke" stroke-width="@PensService.ActivePen.StrokeWidth"
                        opacity="@PensService.ActivePen.Opacity"
                        stroke-linecap="@PensService.ActivePen.StrokeLineCap"
                        stroke-dasharray="@(PensService.ActivePen.LineType == "dashed" ? "8 4" : PensService.ActivePen.LineType == "dotted" ? "2 4" : null)" />
                </svg>
            </span>
        }
    </div>
    <svg @ref="_svg" class="diagram-canvas" width="100%" height="100%" viewBox="0 0 2000 1200"
    style="cursor:@(Editor.Mode == EditorMode.Drawing ? "crosshair" : "default")">
        <g transform="matrix(@Editor.Zoom 0 0 @Editor.Zoom @Editor.OffsetX @Editor.OffsetY)">
        }
        @* Render random rectangle for debug (must be direct child of <svg>) *@
        
            @foreach (var item in Editor.Items)
            {
                switch (item)
                {
                    case PauseHintItem pause:
                        @((MarkupString)$"<!--Pause:{pause.Milliseconds}-->")
                        break;
                    case SpeedHintItem speed:
                        @((MarkupString)$"<!--Speed:{speed.Multiplier}-->")
                        break;
                    case SvgPathItem p:
                        if (p.Selected)
                        {
                            <path d="@p.D" stroke="#00f" stroke-width="@(p.StrokeWidth + 4)" fill="none" opacity="0.5" stroke-linejoin="round" class="glow" />
                        }
                        <path id="@p.Id" d="@p.D" 
                            stroke="@p.Stroke" 
                            stroke-width="@p.StrokeWidth" 
                            fill="none" 
                            opacity="@p.Opacity"
                            stroke-linejoin="round"
                            stroke-linecap="@p.StrokeLineCap"
                            stroke-dasharray="@(p.LineType == "dashed" ? "10 6" : p.LineType == "dotted" ? "3 7" : null)"
                            data-element-type="path"
                            data-path-length="@Path.EstimatedLength(p.D)" />
                        break;
                    case SvgCircleItem c:
                        if (c.Selected)
                        {
                            <circle cx="@c.Cx" cy="@c.Cy" r="@c.R" fill="#00f" stroke="#222" stroke-width="4" opacity="0.5" class="glow" />
                        }
                        <circle id="@c.Id" cx="@c.Cx" cy="@c.Cy" r="@c.R" fill="@c.Fill" opacity="@c.Opacity" data-element-type="circle" />
                        break;
                }
            }        
            @if (Editor.EditingSelectedPaths)
            {
                @foreach (var node in SelectedPathNodesWithType)
                {
                    // Draw nodes for selected items...
                    if (node.isControl)
                    {
                        <circle cx="@node.node.X" cy="@node.node.Y" r="6" fill="#2196f3" stroke="#222" stroke-width="2" opacity="0.85" />
                    }
                    else
                    {
                        <circle cx="@node.node.X" cy="@node.node.Y" r="6" fill="#ffe600" stroke="#222" stroke-width="2" opacity="0.85" />
                    }
                }
                @foreach (var path in Editor.SelectedItems.OfType<SvgPathItem>())
                {
                    // Draw connecting lines and handles for control nodes of selected paths
                    var nodes = Path.GetPathNodesWithType(path);
                    for (int i = 0; i < nodes.Count; i++)
                    {
                        var (node, isControl) = nodes[i];
                        if (isControl)
                        {
                            // Draw handle for control point (smaller circle)
                            <circle cx="@node.X" cy="@node.Y" r="4" fill="#2196f3" stroke="#222" stroke-width="1.5" opacity="0.95" />
                            // Draw connecting line to previous endpoint if possible
                            if (i > 0 && !nodes[i-1].isControl)
                            {
                                var prev = nodes[i-1].node;
                                <line x1="@prev.X" y1="@prev.Y" x2="@node.X" y2="@node.Y" stroke="#2196f3" stroke-width="1.5" opacity="0.7" stroke-dasharray="2 2" />
                            }
                        }
                    }
                }
            }
    
            @if (_activePath != null)
            {
                // Draw new line...
                <path d="@_activePath.D" 
                    stroke="@_activePath.Stroke" 
                    stroke-width="@_activePath.StrokeWidth" 
                    fill="none"
                    opacity="@_activePath.Opacity" 
                    stroke-linecap="@_activePath.StrokeLineCap" />
            }
            @if (_dragSelecting && _dragStart.HasValue && _dragEnd.HasValue)
            { 
                // Draw selection rectangle...
                var (x0, y0) = _dragStart.Value;
                var (x1, y1) = _dragEnd.Value;
                var minX = Math.Min(x0, x1);
                var maxX = Math.Max(x0, x1);
                var minY = Math.Min(y0, y1);
                var maxY = Math.Max(y0, y1);
                <rect x="@minX" y="@minY" width="@(maxX-minX)" height="@(maxY-minY)" fill="#00f" fill-opacity="0.1" stroke="#00f" stroke-dasharray="4 4" />
            }
        </g>
    </svg>
    @if (SettingsSvc.Settings.ShowDebugOverlay)
    {
        <div class="debug-overlay">
            <strong>Debug</strong><br />
            <button class="app-btn" @onclick="DebugAction">Grid</button>
            <br />
            Rect: @_lastSvgRect.x,@_lastSvgRect.y / @_lastSvgRect.w x @_lastSvgRect.h<br />
            Zoom: @Editor.Zoom.ToString("0.00") Off: @Editor.OffsetX.ToString("0.##"),@Editor.OffsetY.ToString("0.##")<br />
            ActivePts: @_points.Count @(_activePath == null ? "(idle)" : "(drawing)")<br />
        </div>
    }    
</div>



@code {
    private Dictionary<SvgCircleItem, (double cx, double cy)>? _dragMoveOriginalCircles;
    private ElementReference _svg;
    private ElementReference _canvasWrapper;
    [Inject] UndoRedoService UndoRedo { get; set; } = default!;
    [Inject] IJSRuntime JS { get; set; } = default!;
    private SvgPathItem? _activePath;
    private List<(double x, double y)> _points = new();
    private bool _panning;
    private (double x, double y) _panStart;
    private (double x, double y) _offsetStart;
    private (double x, double y, double w, double h) _lastSvgRect = (0, 0, 0, 0);
    private bool _dragSelecting;
    private (double x, double y)? _dragStart;
    private (double x, double y)? _dragEnd;
    private bool _dragMovingPaths = false;
    private (double x, double y)? _dragMoveStart;
    private Dictionary<SvgPathItem, List<(double x, double y)>>? _dragMoveOriginalPoints;
    private bool _pendingCircle = false;
    
    private IEnumerable<(Node node, bool isControl)> SelectedPathNodesWithType
    {
        get
        {
            var result = new List<(Node, bool)>();
            foreach (var p in Editor.SelectedItems.OfType<SvgPathItem>())
            {
                result.AddRange(Path.GetPathNodesWithType(p));
            }
            return result;
        }
    }

    void OnToggleModeClick(MouseEventArgs e)
    {
        // Cycle between Drawing and Select (not Animation)
        var nextMode = Editor.Mode == EditorMode.Drawing ? EditorMode.Select : EditorMode.Drawing;
        Editor.SetMode(nextMode);
        StateHasChanged();
    }

    void Undo()
    {
        var state = UndoRedo.Undo(Editor.Serialize());
        if (state != null) Restore(state);
    }

    void Redo()
    {
        var state = UndoRedo.Redo(Editor.Serialize());
        if (state != null) Restore(state);
    }

    void Restore(string json)
    {
        try
        {
            var items = System.Text.Json.JsonSerializer.Deserialize<List<PathItem>>(json);
            if (items != null)
            {
                Editor.Items.Clear();
                foreach (var item in items)
                {
                    Editor.Add(item);
                }
                Editor.MarkSaved();
            }
        }
        catch { }
    }

    string StateSnapshot() => Editor.Serialize();

    string CanvasBgColor => (SettingsSvc.EffectiveTheme == ThemeMode.Dark) ? SettingsSvc.Settings.DarkCanvasColor : SettingsSvc.Settings.LightCanvasColor;

    public class DomRect
    {
        public double x { get; set; }
        public double y { get; set; }
        public double width { get; set; }
        public double height { get; set; }
    }
    
    void OnWheel(WheelEventArgs e)
    {
        var oldZoom = Editor.Zoom;
        var newZoom = oldZoom * (e.DeltaY < 0 ? 1.1 : 0.9);
        newZoom = Math.Clamp(newZoom, 0.1, 10);
        var rect = _lastSvgRect;
        if (rect.w <= 0 || rect.h <= 0) { Editor.SetViewport(newZoom, Editor.OffsetX, Editor.OffsetY); return; }
        var localX = e.ClientX - rect.x;
        var localY = e.ClientY - rect.y;
        var vbX = localX / rect.w * 2000.0;
        var vbY = localY / rect.h * 1200.0;
        var worldXBefore = (vbX - Editor.OffsetX) / oldZoom;
        var worldYBefore = (vbY - Editor.OffsetY) / oldZoom;
        var newOffsetX = vbX - worldXBefore * newZoom;
        var newOffsetY = vbY - worldYBefore * newZoom;
        Editor.SetViewport(newZoom, newOffsetX, newOffsetY);
    }

    async void PointerDown(PointerEventArgs e)
    {
        //Console.WriteLine($"PointerDown: Type={e.Type} PointerType={e.PointerType} button={e.Button} pressure={e.Pressure} AltKey={e.AltKey}");

        // Ignore pen hover (pressure==0), only draw/select on contact
        if (e.Pressure == 0)
            return;

        if(Editor.ModeWhichShoudIgnorePointerEvents)
            return;

        // Eraser detection: Alt+LeftClick acts as eraser (for pen or mouse)
        if (e.AltKey && e.Button == 0)
        {
            var svgHitPoint = ToSvgFromEvent(e);
            var hitPath = Editor.Items.OfType<SvgPathItem>().FirstOrDefault(p => Path.IsNearPoint(svgHitPoint.x, svgHitPoint.y, p));
            var hitCircle = Editor.Items.OfType<SvgCircleItem>().FirstOrDefault(c => Path.IsPointInCircle(svgHitPoint.x, svgHitPoint.y, c));
            if (hitPath != null) Editor.Delete(hitPath);
            if (hitCircle != null) Editor.Delete(hitCircle);
            StateHasChanged();
            return;
        }
        // Barrel button mapped to middle-click (panning) for pen
        if (e.PointerType == "pen" && e.Button == 1)
        {
            _panning = true; 
            _panStart = (e.ClientX, e.ClientY); 
            _offsetStart = (Editor.OffsetX, Editor.OffsetY); 
            return;
        }
        // Mouse middle-click starts panning
        if (e.PointerType == "mouse" && e.Button == 1)
        {
            _panning = true; 
            _panStart = (e.ClientX, e.ClientY); 
            _offsetStart = (Editor.OffsetX, Editor.OffsetY); 
            return;
        }
        // Left-click drag for selection rectangle in select mode
        if (e.Button == 0 && Editor.Mode != EditorMode.Drawing)
        {
            var svgHitPoint = ToSvgFromEvent(e);
            // Use ItemLocationCache for fast hit test
            var hitIds = Editor.LocationCache?.GetItemsAt(svgHitPoint.x, svgHitPoint.y) ?? Array.Empty<string>();
            var hitItems = Editor.Items.Where(i => hitIds.Contains(i.Id)).ToList();
            // Filter for actual hit (path/circle)
            PathItem? hit = null;
            foreach (var item in hitItems)
            {
                if (item is SvgPathItem p && Path.IsNearPoint(svgHitPoint.x, svgHitPoint.y, p))
                {
                    hit = p; break;
                }
                if (item is SvgCircleItem c && Path.IsPointInCircle(svgHitPoint.x, svgHitPoint.y, c))
                {
                    hit = c; break;
                }
            }
            if (hit != null)
            {
                bool skipSelection = false;
                if (Editor.SelectedItems.Count > 1 && Editor.SelectedItems.Contains(hit) && !e.CtrlKey)
                {
                    skipSelection = true;
                }
                if (!skipSelection)
                {
                    if (e.CtrlKey)
                    {
                        var selected = Editor.SelectedItems.ToList();
                        if (hit.Selected)
                            selected.Remove(hit);
                        else
                            selected.Add(hit);
                        Editor.SelectMultiple(selected);
                        Editor.Highlight(hit);
                    }
                    else
                    {
                        Editor.Select(hit);
                        Editor.Highlight(hit);
                    }
                    StateHasChanged();
                }

                // Multi-shape drag: if hit is selected, start drag-move for all selected
                if (Editor.SelectedItems.Contains(hit))
                {
                    _dragMovingPaths = true;
                    _dragMoveStart = svgHitPoint;
                    _dragMoveOriginalPoints = new Dictionary<SvgPathItem, List<(double x, double y)>>();
                    foreach (var path in Editor.SelectedItems.OfType<SvgPathItem>())
                    {
                        var pts = Path.GetPoints(path);
                        _dragMoveOriginalPoints[path] = pts;
                    }
                    // Store original positions for circles
                    _dragMoveOriginalCircles = new Dictionary<SvgCircleItem, (double cx, double cy)>();
                    foreach (var circle in Editor.SelectedItems.OfType<SvgCircleItem>())
                    {
                        _dragMoveOriginalCircles[circle] = (circle.Cx, circle.Cy);
                    }
                }
                return;
            }

            // Otherwise, start drag-select
            _dragSelecting = true;
            _dragStart = svgHitPoint;
            _dragEnd = svgHitPoint;
            Editor.SelectMultiple(Array.Empty<PathItem>());
            Editor.ClearHighlights();
            StateHasChanged();
            return;
        }

        // In draw mode, allow mouse left-click or pen tip contact
        if (Editor.Mode != EditorMode.Drawing || 
            (e.PointerType == "mouse" && e.Button != 0) ||
            (e.PointerType == "pen" && e.Pressure == 0))
            return;

        // Clear selection when starting to draw
        Editor.Select(null);
        Editor.ClearHighlights();
        StateHasChanged();

        await RefreshRectAsync();
        var (sx, sy) = ToSvgFromEvent(e);
        var pen = PensService.ActivePen;

        // Start path drawing        
        _points.Clear();
        _points.Add((sx, sy));
        _activePath = new SvgPathItem {
            D = $"M {sx} {sy}",
            StrokeWidth = pen?.StrokeWidth ?? 2,
            Stroke = pen?.Stroke ?? "#000",
            Opacity = pen?.Opacity ?? 1.0,
            LineType = pen?.LineType ?? "solid",
            StrokeLineCap = pen?.StrokeLineCap ?? "square"
        };        

        // This could be a circle if we subsequently get a pointerUp with no move...
        _pendingCircle = (!e.ShiftKey && !e.CtrlKey && !e.AltKey);    
    }

    void PointerMove(PointerEventArgs e)        
    {
        //Console.WriteLine($"PointerMove: type={e.PointerType} button={e.Button} pressure={e.Pressure}");
        
        // Ignore pen hover 
        if (e.Pressure == 0)
            return;

        if(Editor.ModeWhichShoudIgnorePointerEvents)
            return;

        // Eraser detection: Alt+LeftClick acts as eraser (for pen or mouse) while moving
        if (e.AltKey && e.Button == 0)
        {
            var svgHitPoint = ToSvgFromEvent(e);
            var hitPath = Editor.Items.OfType<SvgPathItem>().FirstOrDefault(p => Path.IsNearPoint(svgHitPoint.x, svgHitPoint.y, p));
            var hitCircle = Editor.Items.OfType<SvgCircleItem>().FirstOrDefault(c => Path.IsPointInCircle(svgHitPoint.x, svgHitPoint.y, c));
            if (hitPath != null) Editor.Delete(hitPath);
            if (hitCircle != null) Editor.Delete(hitCircle);
            StateHasChanged();
            return;
        }

        if (_panning)
        {
            var dx = e.ClientX - _panStart.x;
            var dy = e.ClientY - _panStart.y;
            Editor.SetViewport(Editor.Zoom, _offsetStart.x + dx, _offsetStart.y + dy);
            return;
        }
        if (_dragSelecting && _dragStart.HasValue)
        {
            var svgHitPoint = ToSvgFromEvent(e);
            _dragEnd = svgHitPoint;
            var (x0, y0) = _dragStart.Value;
            var (x1, y1) = svgHitPoint;
            var minX = Math.Min(x0, x1);
            var minY = Math.Min(y0, y1);
            var width = Math.Abs(x1 - x0);
            var height = Math.Abs(y1 - y0);
            // Use ItemLocationCache for fast bucket-based selection, then filter by actual intersection
            var candidateIds = Editor.LocationCache?.GetItemsInRect(minX, minY, width, height) ?? Array.Empty<string>();
            var selected = Editor.Items.Where(i => candidateIds.Contains(i.Id) &&
                ((i is SvgPathItem p && Path.IntersectsRect(p, minX, minY, minX + width, minY + height)) ||
                 (i is SvgCircleItem c && Path.CircleIntersectsRect(c, minX, minY, minX + width, minY + height)))).ToList();

            if (e.CtrlKey)
            {
                // Add to current selection
                var combined = Editor.SelectedItems.Union(selected).ToList();
                Editor.SelectMultiple(combined);
            }
            else
            {
                // Replace selection
                Editor.SelectMultiple(selected);
            }
            Editor.ClearHighlights();
            foreach (var item in Editor.SelectedItems) item.Highlight = true;
            StateHasChanged();
            return;
        }
        
        if (_dragMovingPaths && _dragMoveStart.HasValue && _dragMoveOriginalPoints != null)
        {
            var svgHitPoint = ToSvgFromEvent(e);
            var (startX, startY) = _dragMoveStart.Value;
            var dx = svgHitPoint.x - startX;
            var dy = svgHitPoint.y - startY;
            foreach (var kvp in _dragMoveOriginalPoints)
            {
                var path = kvp.Key;
                var origPts = kvp.Value;
                var movedPts = origPts.Select(pt => (pt.x + dx, pt.y + dy)).ToList();
                path.D = SmoothingStrategies.Linear(movedPts);
            }
            
            if (_dragMoveOriginalCircles != null)
            {
                foreach (var kvp in _dragMoveOriginalCircles)
                {
                    var circle = kvp.Key;
                    var (origCx, origCy) = kvp.Value;
                    circle.Cx = origCx + dx;
                    circle.Cy = origCy + dy;
                }
            }
            StateHasChanged();
            return;
        }

        if (_activePath == null) return;
        var (sx, sy) = ToSvgFromEvent(e);
        if (_points.Last() == (sx, sy)) return;
        _points.Add((sx, sy));

        // Always use linear while drawing for smooth experience
        _activePath.D = SmoothingStrategies.Linear(_points);
    }

    void PointerUp(PointerEventArgs e)
    { 
        if(Editor.ModeWhichShoudIgnorePointerEvents)
            return;

        if (_panning) 
        { 
            _panning = false; return; 
        }
        
        if (_dragSelecting)
        {
            // If drag distance is very small, treat as single click
            double dragDist = 0;
            if (_dragStart.HasValue && _dragEnd.HasValue)
            {
                var (x0, y0) = _dragStart.Value;
                var (x1, y1) = _dragEnd.Value;
                dragDist = Math.Sqrt((x1 - x0) * (x1 - x0) + (y1 - y0) * (y1 - y0));
            }
            if (dragDist < 2.0)
            {
                // Treat as single click
                var svgHitPoint = _dragStart ?? (0, 0);
                var candidateIds = Editor.LocationCache?.GetItemsAt(svgHitPoint.x, svgHitPoint.y) ?? Array.Empty<string>();
                var items = Editor.Items.Where(i => candidateIds.Contains(i.Id)).ToList();
                double radius = 10.0;
                var hitItems = items.Where(i =>
                    (i is SvgPathItem p && Path.IntersectsCircle(p, svgHitPoint.x, svgHitPoint.y, radius)) ||
                    (i is SvgCircleItem c && Path.CircleIntersectsCircle(c, svgHitPoint.x, svgHitPoint.y, radius)))
                    .ToList();
                var hitTestIds = hitItems.Select(i => i.Id)
                    .Where(id => id.StartsWith("test-path-"))
                    .ToList();
                Editor.SelectMultiple(hitItems);
    
            }
            else
            {
                // Log selected testPath ids for diagnosis (now finalized)
                var selectedTestIds = Editor.SelectedItems.Select(i => i.Id).Where(id => id.StartsWith("test-path-")).ToList();
                Console.WriteLine($"DragSelect items: {string.Join(", ", selectedTestIds)}");
            }
            _dragSelecting = false;
            _dragStart = null;
            _dragEnd = null;
            StateHasChanged();
            return;
        }
        
        // Log single-click select for testPath items
        if (!_dragSelecting && !_panning && e.Button == 0)
        {
            var svgHitPoint = ToSvgFromEvent(e);
            var hitIds = Editor.LocationCache?.GetItemsAt(svgHitPoint.x, svgHitPoint.y) ?? Array.Empty<string>();
            var hitTestIds = hitIds.Where(id => id.StartsWith("test-path-")).ToList();
            Console.WriteLine($"SingleClick: x={svgHitPoint.x:F1} y={svgHitPoint.y:F1}");
            Console.WriteLine($"SingleClick items: {string.Join(", ", hitTestIds)}");
        }        

        // End multi-shape drag-move
        if (_dragMovingPaths)
        {
            _dragMovingPaths = false;
            _dragMoveStart = null;
            _dragMoveOriginalPoints = null;
            _dragMoveOriginalCircles = null;
            // Push state for undo/redo
            UndoRedo.PushState(StateSnapshot());
            StateHasChanged();
            return;
        }

        // If no mouse movement, create a circle
        if (_pendingCircle && _activePath != null && _points.Count == 1)
        {
            var pen = PensService.ActivePen;
            var (cx, cy) = _points[0];
            var circle = new SvgCircleItem {
                Cx = cx,
                Cy = cy,
                R = (pen?.StrokeWidth ?? 2) / 2.0,
                Fill = pen?.Stroke ?? "#000",
                Opacity = pen?.Opacity ?? 1.0
            };
            Editor.Add(circle);
            UndoRedo.PushState(StateSnapshot());
            StateHasChanged();
            _activePath = null;
            _pendingCircle = false;
            return;
        }

        if (_activePath != null)
        {            
            // finalize with selected smoothing
            int minStep = 2, maxStep = 10;
            int step = minStep;
            if (SettingsSvc.Settings.ExtremeAutoSmoothingOfStraightishLines)
            {
                step = maxStep;
            }
            _activePath.D = SmoothingStrategies.BuildPath(_points, SettingsSvc.Settings.SmoothingStrategy, step);            
            Editor.Add(_activePath);
            UndoRedo.PushState(StateSnapshot());
            _activePath = null;
        }
        _pendingCircle = false;
    }

    (double x, double y) ToSvgFromEvent(PointerEventArgs e)
    {
        var rect = _lastSvgRect;
        if (rect.w <= 0 || rect.h <= 0) return (0, 0);
        double localX = e.ClientX - rect.x;
        double localY = e.ClientY - rect.y;
        var vbX = localX / rect.w * 2000.0;
        var vbY = localY / rect.h * 1200.0;
        var x = (vbX - Editor.OffsetX) / Editor.Zoom;
        var y = (vbY - Editor.OffsetY) / Editor.Zoom;
        return (x, y);
    }

    async Task RefreshRectAsync()
    {
        try
        {
            var rect = await JS.InvokeAsync<DomRect>("canvasInterop.getRect", _svg);
            _lastSvgRect = (rect.x, rect.y, rect.width, rect.height);
        }
        catch { }
    }

    private async void DuplicateSelectedPaths()
    {
        if (Editor.SelectedItems.Count == 0)
            return;

        var mousePos = await GetMouseSvgPositionAsync();

        // Find indices of selected items
        var selectedIndices = Editor.SelectedItems.Select(item => Editor.Items.IndexOf(item)).Where(i => i >= 0).OrderBy(i => i).ToList();
        int insertIndex = selectedIndices.Count > 0 ? selectedIndices.Last() + 1 : Editor.Items.Count;

        var newItems = new List<PathItem>();
        foreach (var item in Editor.SelectedItems)
        {
            PathItem? copy = null;
            if (item is SvgPathItem path)
            {
                copy = new SvgPathItem
                {
                    Id = Guid.NewGuid().ToString(),
                    D = Path.OffsetPathD(path.D, mousePos),
                    Stroke = path.Stroke,
                    StrokeWidth = path.StrokeWidth,
                    Opacity = path.Opacity,
                    LineType = path.LineType,
                    StrokeLineCap = path.StrokeLineCap
                };
            }
            else if (item is SvgCircleItem circle)
            {
                copy = new SvgCircleItem
                {
                    Id = Guid.NewGuid().ToString(),
                    Cx = circle.Cx + mousePos.x,
                    Cy = circle.Cy + mousePos.y,
                    R = circle.R,
                    Fill = circle.Fill,
                    Opacity = circle.Opacity
                };
            }
            if (copy != null)
                newItems.Add(copy);
        }

        // Insert new items just below originals
        if (newItems.Count > 0)
        {
            Editor.Items.InsertRange(insertIndex, newItems);
            Editor.SelectMultiple(newItems);
            StateHasChanged();
        }
    }

    private async Task<(double x, double y)> GetMouseSvgPositionAsync()
    {
        try
        {
            var pos = await JS.InvokeAsync<dynamic>("canvasInterop.getMouseSvgPosition", _svg);
            return ((double)pos.x, (double)pos.y);
        }
        catch
        {
            return (40, 40);
        }
    }    

    protected override void OnInitialized()
    {
        Editor.InitLocationCache(3, 3, 2000, 1200);

        // Subscribe to Editor.Changed event for redraws after import or state changes
        Editor.Changed += StateHasChanged;
        SettingsSvc.Changed += StateHasChanged;
        PensService.Changed += StateHasChanged;
        // Ensure keybinding works immediately by focusing canvas wrapper
        _ = Task.Run(async () => {
            await Task.Delay(100);
            await InvokeAsync(async () => await _canvasWrapper.FocusAsync());
        });
    }

    public void Dispose()
    {
        Editor.Changed -= StateHasChanged;
        SettingsSvc.Changed -= StateHasChanged;
        PensService.Changed -= StateHasChanged;
    }

    public void DeleteSelectedPaths() => Editor.DeleteSelected();

    public void DebugAction()
    {
        Console.WriteLine($"Cache contents: {Editor.LocationCache?.GetBucketsDebugString() ?? "No cache"}");
    }
    
}