<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Animated SVG Diagram</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <!-- Hamburger Menu Button -->
    <button class="hamburger-menu" id="hamburgerBtn">
        ‚ò∞
    </button>
    
    <!-- Controls Panel (Hidden by default) -->
    <div class="controls-panel" id="controlsPanel">
        <div class="controls-panel-header">
            <h3 class="controls-panel-title">Animation Controls</h3>
            <button class="close-panel-btn" id="closePanelBtn">√ó</button>
        </div>
        
        <div class="controls">
            <div class="control-group">
                <label for="svgFile">SVG File:</label>
                <div class="control-inputs">
                    <select id="svgFile">
                        <option value="aspire-wire-up.svg">Loading...</option>
                    </select>
                    <button id="newSvgBtn" class="btn-secondary">New</button>
                    <button id="browseSvgBtn" class="btn-secondary">Browse...</button>
                    <input type="file" id="svgFileInput" accept=".svg" style="display: none;">
                </div>
            </div>
            
            <div class="control-group">
                <label>View Controls:</label>
                <div class="control-inputs zoom-controls">
                    <button id="zoomInBtn" class="btn-secondary" title="Zoom In">üîç+</button>
                    <button id="zoomOutBtn" class="btn-secondary" title="Zoom Out">üîç‚àí</button>
                    <button id="zoomFitBtn" class="btn-secondary" title="Zoom to Fit">üìê</button>
                    <button id="resetViewBtn" class="btn-secondary" title="Reset View">üè†</button>
                    <span id="zoomLevel" class="zoom-indicator">100%</span>
                    <div class="tool-mode-divider"></div>
                    <button id="selectModeBtn" class="btn-secondary mode-btn active" title="Select/Pan/Zoom Mode">üìç Select</button>
                    <button id="penModeBtn" class="btn-secondary mode-btn" title="Drawing Mode">
                        <span class="pen-indicator" id="penIndicator"></span>
                        ‚úèÔ∏è <span id="penModeText">Pen 1</span>
                    </button>
                </div>
            </div>
            
            <div class="pens-section">
                <div class="pens-header">
                    <h3>Drawing Pens</h3>
                    <button class="pens-toggle" id="pensToggle">Show</button>
                </div>
                <div class="pens-content" id="pensContent">
                    <div class="pen-configs">
                        <!-- Pen configurations will be dynamically generated here -->
                    </div>
                </div>
            </div>
            
            <div class="control-group">
                <label for="speed">Base Speed (ms per 100 units):</label>
                <div class="control-inputs">
                    <input type="range" id="speed" min="50" max="2000" value="500" step="50">
                    <input type="number" id="speedValue" min="50" max="2000" value="500" step="50">
                </div>
            </div>
            
            <div class="control-group">
                <label for="delay">Delay Between Elements (ms):</label>
                <div class="control-inputs">
                    <input type="range" id="delay" min="0" max="1000" value="100" step="25">
                    <input type="number" id="delayValue" min="0" max="1000" value="100" step="25">
                </div>
            </div>
            
            <div class="buttons">&nbsp;
                <button id="playPauseBtn" class="btn-primary">‚ñ∂ Start Animation</button>
                <button id="resetBtn" class="btn-secondary">‚ü≤ Clear</button>
                <button id="completeBtn" class="btn-success">‚è≠ Show Complete</button>
            </div>
            
            <div class="rules-section">
                <div class="rules-header">
                    <h3>Style Override Rules</h3>
                    <button class="rules-toggle" id="rulesToggle">Show</button>
                </div>
                <div class="rules-content" id="rulesContent">
                    <div id="rulesList"></div>
                    <button class="add-rule-btn" id="addRuleBtn">+ Add Rule</button>
                    <button class="clear-rules-btn" id="clearRulesBtn">Clear All Rules</button>
                    <button class="export-rules-btn" id="exportRulesBtn">Export Rules</button>
                    <div class="import-rules-container">
                        <button class="import-rules-btn" id="importRulesBtn">Import Rules</button>
                        <input type="file" id="importFileInput" class="file-input" accept=".json">
                    </div>
                </div>
            </div>
            
            <div class="path-editor-section">
                <div class="path-editor-header">
                    <h3>Path Editor</h3>
                    <button class="path-editor-toggle" id="pathEditorToggle">Show</button>
                </div>
                <div class="path-editor-content" id="pathEditorContent">
                    <div class="path-editor-layout">
                        <div class="path-list-container">
                            <div class="path-list-header">
                                <h4>Paths & Elements</h4>
                                <div class="selection-controls">
                                    <button class="btn-mini" id="selectAllBtn">All</button>
                                    <button class="btn-mini" id="selectNoneBtn">None</button>
                                    <button class="btn-mini" id="selectInvertBtn">Invert</button>
                                </div>
                            </div>
                            <div class="path-list" id="pathList">
                                <!-- Path items will be dynamically populated here -->
                            </div>
                        </div>
                        
                        <div class="path-properties-container">
                            <div class="path-properties-header">
                                <h4>Properties</h4>
                                <span id="selectionCount">No selection</span>
                            </div>
                            <div class="path-properties" id="pathProperties">
                                <div class="no-selection">Select path(s) to view properties</div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="path-editor-actions">
                        <div class="button-row">
                            <button class="btn-secondary" id="moveUpBtn" disabled>‚Üë Move Up</button>
                            <button class="btn-secondary" id="moveDownBtn" disabled>‚Üì Move Down</button>
                            <button class="btn-secondary" id="moveToTopBtn" disabled>‚áà To Top</button>
                            <button class="btn-secondary" id="moveToBottomBtn" disabled>‚áä To Bottom</button>
                        </div>
                        <div class="button-row">
                            <button class="btn-action" id="insertPauseBtn" disabled>‚è∏Ô∏è Insert Pause</button>
                            <button class="btn-action" id="insertSpeedHintBtn" disabled>‚ö° Insert Speed Hint</button>
                            <button class="btn-danger" id="deletePathsBtn" disabled>üóëÔ∏è Delete</button>
                            <button class="btn-success" id="exportSvgBtn" disabled>üíæ Export SVG</button>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="recording-section">
                <div class="recording-header">
                    <h3>Video Recording</h3>
                    <button class="recording-toggle" id="recordingToggle">Show</button>
                </div>
                <div class="recording-content" id="recordingContent">
                    <div class="recording-controls-compact">
                        <div class="compact-row">
                            <label>FPS:</label>
                            <select id="recordFrameRate">
                                <option value="24">24</option>
                                <option value="30" selected>30</option>
                                <option value="60">60</option>
                            </select>
                            <label>Res:</label>
                            <select id="recordResolution">
                                <option value="720p">720p (1280x720)</option>
                                <option value="1080p" selected>1080p (1920x1080)</option>
                                <option value="1440p">1440p (2560x1440)</option>
                                <option value="4k">4K (3840x2160)</option>
                            </select>
                        </div>
                        <div class="compact-row">
                            <label>Quality:</label>
                            <select id="recordBitrate">
                                <option value="5">5 Mbps</option>
                                <option value="15">15 Mbps</option>
                                <option value="25" selected>25 Mbps</option>
                                <option value="40">40 Mbps</option>
                            </select>
                        </div>
                        <div class="compact-row">
                            <label>Pause at end:</label>
                            <input type="number" id="recordEndPauseValue" min="0" max="3000" value="500" step="100" style="width: 60px;">
                            <span style="font-size: 11px;">ms</span>
                        </div>
                        <div class="compact-row">
                            <label>Show complete SVG at start:</label>
                            <input type="checkbox" id="recordShowCompleteStart" checked>
                            <label style="font-size: 11px; min-width: auto; margin-left: 5px;">200ms preview</label>
                        </div>
                    </div>
                    <button id="recordBtn" class="btn-record">üé• Record Video</button>
                </div>
            </div>
            
            <div class="progress-info">
                <span id="progressText">Ready to animate elements</span>
                <div style="margin-top: 5px; font-size: 11px;">
                    <span id="pathStatsText">Analyzing elements...</span>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Main Content Area -->
    <div class="container">
        <div class="svg-section" id="svgSection">
            <div class="svg-container">
                <!-- SVG content will be loaded here -->
                <div id="svg-placeholder">Loading SVG...</div>
            </div>
        </div>
    </div>

    <script src="animation.js"></script>
    <script>
        // Hamburger menu functionality
        function initializeHamburgerMenu() {
            const hamburgerBtn = document.getElementById('hamburgerBtn');
            const controlsPanel = document.getElementById('controlsPanel');
            const closePanelBtn = document.getElementById('closePanelBtn');
            const svgSection = document.getElementById('svgSection');
            
            console.log('Hamburger menu elements:', {
                hamburgerBtn: !!hamburgerBtn,
                controlsPanel: !!controlsPanel,
                closePanelBtn: !!closePanelBtn,
                svgSection: !!svgSection
            });
            
            if (!hamburgerBtn || !controlsPanel || !closePanelBtn || !svgSection) {
                console.error('Missing hamburger menu elements');
                return;
            }
            
            function openPanel() {
                console.log('Opening panel');
                controlsPanel.classList.add('open');
                svgSection.classList.add('panel-open');
                hamburgerBtn.classList.add('hidden');
            }
            
            function closePanel() {
                console.log('Closing panel');
                controlsPanel.classList.remove('open');
                svgSection.classList.remove('panel-open');
                hamburgerBtn.classList.remove('hidden');
            }
            
            hamburgerBtn.addEventListener('click', openPanel);
            closePanelBtn.addEventListener('click', closePanel);
            
            // Toggle panel on Escape key
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    if (controlsPanel.classList.contains('open')) {
                        closePanel();
                    } else {
                        openPanel();
                    }
                }
            });
        }
        
        // Style override rules functionality
        window.styleRules = [];
        const STORAGE_KEY = 'svg-animation-style-rules';
        
        function loadRulesFromStorage() {
            try {
                const stored = localStorage.getItem(STORAGE_KEY);
                if (stored) {
                    window.styleRules = JSON.parse(stored);
                    console.log('Loaded rules from storage:', window.styleRules);
                    return window.styleRules;
                }
            } catch (error) {
                console.warn('Failed to load rules from storage:', error);
            }
            return [];
        }
        
        function saveRulesToStorage() {
            try {
                localStorage.setItem(STORAGE_KEY, JSON.stringify(window.styleRules));
                console.log('Saved rules to storage:', window.styleRules);
            } catch (error) {
                console.warn('Failed to save rules to storage:', error);
            }
        }
        
        function initializeRulesUI() {
            // Toggle rules section
            // Unified collapsible section management
            function setupCollapsibleSection(toggleId, contentId) {
                const toggle = document.getElementById(toggleId);
                const content = document.getElementById(contentId);
                
                if (!toggle || !content) return;
                
                toggle.addEventListener('click', () => {
                    if (content.classList.contains('show')) {
                        content.classList.remove('show');
                        toggle.textContent = 'Show';
                    } else {
                        content.classList.add('show');
                        toggle.textContent = 'Hide';
                    }
                });
            }

            // Setup all collapsible sections
            setupCollapsibleSection('rulesToggle', 'rulesContent');
            setupCollapsibleSection('recordingToggle', 'recordingContent');
            setupCollapsibleSection('pensToggle', 'pensContent');

            // Add new rule
            document.getElementById('addRuleBtn').addEventListener('click', () => {
                addRule();
            });
            
            // Clear all rules
            document.getElementById('clearRulesBtn').addEventListener('click', () => {
                if (confirm('Are you sure you want to clear all rules? This action cannot be undone.')) {
                    clearAllRules();
                }
            });
            
            // Export rules
            document.getElementById('exportRulesBtn').addEventListener('click', () => {
                exportRules();
            });
            
            // Import rules
            document.getElementById('importRulesBtn').addEventListener('click', () => {
                document.getElementById('importFileInput').click();
            });
            
            document.getElementById('importFileInput').addEventListener('change', (e) => {
                importRules(e.target.files[0]);
            });

            // Load default rules from JSON file
            async function loadDefaultRules() {
                try {
                    const response = await fetch('./default-rules.json');
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }
                    const data = await response.json();
                    return data.rules || [];
                } catch (error) {
                    console.error('Error loading default rules:', error);
                    // Fallback to hardcoded rules if file load fails
                    return [
                        {
                            name: "Handwriting Detection",
                            isSystem: true,
                            conditions: [
                                { property: 'stroke', value: '#000000' },
                                { property: 'path-length', value: '200' }
                            ],
                            actions: [
                                { property: 'stroke-width', value: '1.5' },
                                { property: 'opacity', value: '0.9' },
                                { property: 'stroke-opacity', value: '1.0' },
                                { property: 'animation-speed', value: '100' }
                            ]
                        },
                        {
                            name: "Thick Lines (Slow)",
                            isSystem: false,
                            conditions: [{ property: 'stroke-width', value: '12.000' }],
                            actions: [
                                { property: 'stroke-width', value: '19.000' },
                                { property: 'animation-speed', value: '800' }
                            ]
                        },
                        {
                            name: "Faded Elements (Fast)",
                            isSystem: false,
                            conditions: [{ property: 'opacity', value: '0.247' }],
                            actions: [
                                { property: 'opacity', value: '1.0' },
                                { property: 'animation-speed', value: '0.6' }
                            ]
                        },
                        {
                            name: "Golden Glow for Text",
                            isSystem: false,
                            conditions: [{ property: 'stroke', value: '#000000' }],
                            actions: [
                                { property: 'glow-effect', value: '#ffd700,12' }
                            ]
                        },
                        {
                            name: "Test Glow for All Paths",
                            isSystem: false,
                            conditions: [{ property: 'path-length', value: '1000', operator: '<' }],
                            actions: [
                                { property: 'glow-effect', value: '#ff0000,6' }
                            ]
                        }
                    ];
                }
            }
            
            // Initialize rules system
            async function initializeRules() {
                // Load existing rules from storage
                const existingRules = loadRulesFromStorage();
                
                // Check if we have any system rules
                const hasSystemRules = existingRules.some(rule => rule.isSystem);
                
                if (existingRules.length > 0) {
                    // Load existing rules from storage
                    existingRules.forEach(rule => {
                        // Handle backward compatibility with old single-condition/action rules
                        if (rule.property && rule.value && rule.targetProperty && rule.targetValue) {
                            // Old single condition/action format
                            const conditions = [{ property: rule.property, value: rule.value }];
                            const actions = [{ property: rule.targetProperty, value: rule.targetValue }];
                            addRule(conditions, actions, rule.name || 'Legacy Rule', rule.isSystem || false);
                        } else if (rule.conditions && rule.targetProperty && rule.targetValue) {
                            // Multi-condition, single action format
                            const actions = [{ property: rule.targetProperty, value: rule.targetValue }];
                            addRule(rule.conditions, actions, rule.name || 'Legacy Rule', rule.isSystem || false);
                        } else if (rule.conditions && rule.actions) {
                            // New multi-condition, multi-action format
                            addRule(rule.conditions, rule.actions, rule.name || 'Custom Rule', rule.isSystem || false);
                        }
                    });
                }
                
                // Always load default rules if we don't have system rules
                if (!hasSystemRules) {
                    const defaultRules = await loadDefaultRules();
                    defaultRules.forEach(rule => {
                        addRule(rule.conditions, rule.actions, rule.name, rule.isSystem || false);
                    });
                }
            }
            
            // Initialize the rules system
            initializeRules();
        }
        
        function createActionValueInput(property, value = '') {
            if (property === 'animation-speed') {
                // Create slider for animation speed multiplier (0.2x to 3.0x)
                const sliderValue = value || '1.0';
                return `
                    <input type="range" class="action-value action-slider" 
                           min="0.2" max="3.0" step="0.1" value="${sliderValue}"
                           oninput="this.nextElementSibling.textContent = this.value + 'x'">
                    <span class="slider-value">${sliderValue}x</span>
                `;
            } else if (property === 'glow-effect') {
                // Parse current value (format: "color" or "color,size")
                let currentColor = '#ffd700';
                let currentSize = 8;
                
                if (value) {
                    if (value.includes(',')) {
                        const parts = value.split(',');
                        currentColor = parts[0].trim();
                        currentSize = parseInt(parts[1].trim()) || 8;
                    } else {
                        currentColor = value;
                    }
                }
                
                return `
                    <div class="glow-controls">
                        <input type="color" class="glow-color" value="${currentColor}"
                               oninput="updateGlowValue(this)">
                        <input type="range" class="glow-size" min="2" max="20" step="1" value="${currentSize}"
                               oninput="updateGlowValue(this)">
                        <span class="glow-size-label">${currentSize}px</span>
                        <input type="hidden" class="action-value" value="${currentColor},${currentSize}">
                    </div>
                `;
            } else {
                // Regular text input for other properties
                return `<input type="text" class="action-value" value="${value}" placeholder="new value">`;
            }
        }
        
        function updateGlowValue(changedInput) {
            const glowControls = changedInput.closest('.glow-controls');
            const colorInput = glowControls.querySelector('.glow-color');
            const sizeInput = glowControls.querySelector('.glow-size');
            const sizeLabel = glowControls.querySelector('.glow-size-label');
            const hiddenInput = glowControls.querySelector('.action-value');
            
            // Update size label
            sizeLabel.textContent = sizeInput.value + 'px';
            
            // Update hidden input with combined value
            hiddenInput.value = `${colorInput.value},${sizeInput.value}`;
        }
        
        function setupActionPropertyListeners(ruleDiv) {
            const actionItems = ruleDiv.querySelectorAll('.action-item');
            actionItems.forEach(actionItem => {
                const propertySelect = actionItem.querySelector('.action-property');
                if (propertySelect && !propertySelect.hasAttribute('data-listener-added')) {
                    propertySelect.setAttribute('data-listener-added', 'true');
                    propertySelect.addEventListener('change', function() {
                        const valueContainer = this.parentNode;
                        const equalSpan = valueContainer.querySelector('span:nth-of-type(2)'); // The "=" span
                        
                        // Get current value before removing
                        const currentValue = valueContainer.querySelector('.action-value')?.value || '';
                        
                        // Remove existing input/slider
                        const existingInput = valueContainer.querySelector('.action-value');
                        const existingSliderValue = valueContainer.querySelector('.slider-value');
                        if (existingInput) existingInput.remove();
                        if (existingSliderValue) existingSliderValue.remove();
                        
                        // Create new input based on property type
                        const newInputHtml = createActionValueInput(this.value, currentValue);
                        equalSpan.insertAdjacentHTML('afterend', newInputHtml);
                        
                        // Add event listeners to new input
                        const newInput = valueContainer.querySelector('.action-value');
                        newInput.addEventListener('change', updateStyleRules);
                        newInput.addEventListener('input', updateStyleRules);
                        
                        updateStyleRules();
                    });
                }
                
                // Also add input event listener for sliders
                const actionValue = actionItem.querySelector('.action-value');
                if (actionValue && actionValue.type === 'range') {
                    actionValue.addEventListener('input', updateStyleRules);
                }
            });
        }
        
        function addRule(conditions = null, actions = null, name = null, isSystem = false) {
            const ruleId = 'rule_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
            const ruleDiv = document.createElement('div');
            ruleDiv.className = 'rule-item';
            ruleDiv.id = ruleId;
            
            // Mark system rules
            if (isSystem) {
                ruleDiv.classList.add('system-rule');
                ruleDiv.dataset.isSystem = 'true';
            }
            
            // Default conditions if none provided
            if (!conditions) {
                conditions = [{ property: 'stroke-width', value: '' }];
            }
            
            // Default actions if none provided
            if (!actions) {
                actions = [{ property: 'stroke-width', value: '' }];
            }
            
            // Default name if none provided
            if (!name) {
                name = isSystem ? 'System Rule' : 'Custom Rule';
            }
            
            let conditionsHtml = '';
            conditions.forEach((condition, index) => {
                const conditionId = `condition_${ruleId}_${index}`;
                conditionsHtml += `
                    <div class="condition-group" data-condition-index="${index}">
                        ${index > 0 ? '<span style="font-weight: bold;">AND</span>' : '<span>If</span>'}
                        <select class="condition-property">
                            <option value="stroke-width" ${condition.property === 'stroke-width' ? 'selected' : ''}>stroke-width</option>
                            <option value="stroke" ${condition.property === 'stroke' ? 'selected' : ''}>stroke color</option>
                            <option value="fill" ${condition.property === 'fill' ? 'selected' : ''}>fill color</option>
                            <option value="opacity" ${condition.property === 'opacity' ? 'selected' : ''}>opacity</option>
                            <option value="stroke-opacity" ${condition.property === 'stroke-opacity' ? 'selected' : ''}>stroke-opacity</option>
                            <option value="fill-opacity" ${condition.property === 'fill-opacity' ? 'selected' : ''}>fill-opacity</option>
                            <option value="path-length" ${condition.property === 'path-length' ? 'selected' : ''}>path length</option>
                            <option value="animation-speed" ${condition.property === 'animation-speed' ? 'selected' : ''}>animation speed</option>
                        </select>
                        <select class="condition-operator">
                            <option value="=" ${(condition.operator || '=') === '=' ? 'selected' : ''}>=</option>
                            <option value="<" ${(condition.operator || '=') === '<' ? 'selected' : ''}>&lt;</option>
                            <option value=">" ${(condition.operator || '=') === '>' ? 'selected' : ''}>&gt;</option>
                            <option value="<=" ${(condition.operator || '=') === '<=' ? 'selected' : ''}>&le;</option>
                            <option value=">=" ${(condition.operator || '=') === '>=' ? 'selected' : ''}>&ge;</option>
                        </select>
                        <input type="text" class="condition-value" value="${condition.value || ''}" placeholder="value">
                        ${conditions.length > 1 ? `<button class="remove-condition-btn" onclick="removeCondition(event, '${ruleId}', ${index})">√ó</button>` : ''}
                    </div>
                `;
            });
            
            let actionsHtml = '';
            actions.forEach((action, index) => {
                actionsHtml += `
                    <div class="action-item" data-action-index="${index}">
                        ${index > 0 ? '<span style="font-weight: bold;">AND</span>' : '<span>then set</span>'}
                        <select class="action-property">
                            <option value="stroke-width" ${action.property === 'stroke-width' ? 'selected' : ''}>stroke-width</option>
                            <option value="stroke" ${action.property === 'stroke' ? 'selected' : ''}>stroke color</option>
                            <option value="fill" ${action.property === 'fill' ? 'selected' : ''}>fill color</option>
                            <option value="opacity" ${action.property === 'opacity' ? 'selected' : ''}>opacity</option>
                            <option value="stroke-opacity" ${action.property === 'stroke-opacity' ? 'selected' : ''}>stroke-opacity</option>
                            <option value="fill-opacity" ${action.property === 'fill-opacity' ? 'selected' : ''}>fill-opacity</option>
                            <option value="animation-speed" ${action.property === 'animation-speed' ? 'selected' : ''}>animation speed (multiplier)</option>
                            <option value="glow-effect" ${action.property === 'glow-effect' ? 'selected' : ''}>glow effect</option>
                        </select>
                        <span>=</span>
                        ${createActionValueInput(action.property, action.value)}
                        ${actions.length > 1 ? `<button class="remove-action-btn" onclick="removeAction(event, '${ruleId}', ${index})">√ó</button>` : ''}
                    </div>
                `;
            });
            
            ruleDiv.innerHTML = `
                <div class="rule-header">
                    <input type="text" class="rule-name-input" value="${name}" placeholder="Rule name" ${isSystem ? 'readonly' : ''}>
                </div>
                <div class="conditions-container">
                    ${conditionsHtml}
                    <button class="add-condition-btn" onclick="addCondition('${ruleId}')">+ Add Condition</button>
                </div>
                <div class="action-group">
                    ${actionsHtml}
                    <div class="action-buttons-row">
                        <button class="add-action-btn" onclick="addAction('${ruleId}')">+ Add Action</button>
                        <div class="rule-actions">
                            <button class="show-btn" onclick="showRuleMatches('${ruleId}')">üëÅ Show</button>
                            <button class="duplicate-btn" onclick="duplicateRule('${ruleId}')">‚éò Duplicate</button>
                            <button class="remove-btn" onclick="removeRule('${ruleId}')" ${isSystem ? 'style="display:none"' : ''}>√ó Remove</button>
                        </div>
                    </div>
                </div>
            `;
            
            document.getElementById('rulesList').appendChild(ruleDiv);
            
            // Add event listeners for this rule
            const inputs = ruleDiv.querySelectorAll('input, select');
            inputs.forEach(input => {
                input.addEventListener('change', updateStyleRules);
                if (input.type === 'range') {
                    input.addEventListener('input', updateStyleRules);
                }
            });
            
            // Setup property change listeners for dynamic input switching
            setupActionPropertyListeners(ruleDiv);
            
            updateStyleRules();
        }
        
        function addAction(ruleId) {
            const ruleDiv = document.getElementById(ruleId);
            const actionGroup = ruleDiv.querySelector('.action-group');
            const addActionBtn = actionGroup.querySelector('.action-buttons-row .add-action-btn');
            const existingActions = actionGroup.querySelectorAll('.action-item');
            const newIndex = existingActions.length;
            
            const actionDiv = document.createElement('div');
            actionDiv.className = 'action-item';
            actionDiv.setAttribute('data-action-index', newIndex);
            
            actionDiv.innerHTML = `
                <span style="font-weight: bold;">AND</span>
                <select class="action-property">
                    <option value="stroke-width">stroke-width</option>
                    <option value="stroke">stroke color</option>
                    <option value="fill">fill color</option>
                    <option value="opacity">opacity</option>
                    <option value="stroke-opacity">stroke-opacity</option>
                    <option value="fill-opacity">fill-opacity</option>
                    <option value="animation-speed">animation speed (multiplier)</option>
                    <option value="glow-effect">glow effect</option>
                </select>
                <span>=</span>
                ${createActionValueInput('stroke-width', '')}
                <button class="remove-action-btn" onclick="removeAction(event, '${ruleId}', ${newIndex})">√ó</button>
            `;
            
            actionGroup.insertBefore(actionDiv, actionGroup.querySelector('.action-buttons-row'));
            
            // Add event listeners
            const inputs = actionDiv.querySelectorAll('input, select');
            inputs.forEach(input => {
                input.addEventListener('change', updateStyleRules);
                if (input.type === 'range') {
                    input.addEventListener('input', updateStyleRules);
                }
            });
            
            // Setup property change listeners
            setupActionPropertyListeners(actionDiv.parentNode);
            
            updateStyleRules();
        }
        
        function removeAction(event, ruleId, actionIndex) {
            event.stopPropagation(); // Prevent panel from closing
            
            const ruleDiv = document.getElementById(ruleId);
            const actions = ruleDiv.querySelectorAll('.action-item');
            
            if (actions.length <= 1) {
                alert('A rule must have at least one action.');
                return;
            }
            
            const actionToRemove = Array.from(actions).find(a => 
                parseInt(a.getAttribute('data-action-index')) === actionIndex
            );
            
            if (actionToRemove) {
                actionToRemove.remove();
                updateStyleRules();
            }
        }
        
        function addCondition(ruleId) {
            const ruleDiv = document.getElementById(ruleId);
            const conditionsContainer = ruleDiv.querySelector('.conditions-container');
            const addConditionBtn = conditionsContainer.querySelector('.add-condition-btn');
            const existingConditions = conditionsContainer.querySelectorAll('.condition-group');
            const newIndex = existingConditions.length;
            
            const conditionDiv = document.createElement('div');
            conditionDiv.className = 'condition-group';
            conditionDiv.setAttribute('data-condition-index', newIndex);
            
            conditionDiv.innerHTML = `
                <span style="font-weight: bold;">AND</span>
                <select class="condition-property">
                    <option value="stroke-width">stroke-width</option>
                    <option value="stroke">stroke color</option>
                    <option value="fill">fill color</option>
                    <option value="opacity">opacity</option>
                    <option value="stroke-opacity">stroke-opacity</option>
                    <option value="fill-opacity">fill-opacity</option>
                    <option value="path-length">path length</option>
                    <option value="animation-speed">animation speed</option>
                </select>
                <select class="condition-operator">
                    <option value="=">=</option>
                    <option value="<">&lt;</option>
                    <option value=">">&gt;</option>
                    <option value="<=">&le;</option>
                    <option value=">=">&ge;</option>
                </select>
                <input type="text" class="condition-value" value="" placeholder="value">
                <button class="remove-condition-btn" onclick="removeCondition(event, '${ruleId}', ${newIndex})">√ó</button>
            `;
            
            conditionsContainer.insertBefore(conditionDiv, addConditionBtn);
            
            // Add event listeners
            const inputs = conditionDiv.querySelectorAll('input, select');
            inputs.forEach(input => {
                input.addEventListener('change', updateStyleRules);
            });
            
            updateStyleRules();
        }
        
        function removeCondition(event, ruleId, conditionIndex) {
            event.stopPropagation(); // Prevent panel from closing
            
            const ruleDiv = document.getElementById(ruleId);
            const conditions = ruleDiv.querySelectorAll('.condition-group');
            
            if (conditions.length <= 1) {
                alert('A rule must have at least one condition.');
                return;
            }
            
            const conditionToRemove = Array.from(conditions).find(c => 
                parseInt(c.getAttribute('data-condition-index')) === conditionIndex
            );
            
            if (conditionToRemove) {
                conditionToRemove.remove();
                updateStyleRules();
            }
        }
        
        function duplicateRule(ruleId) {
            const ruleDiv = document.getElementById(ruleId);
            
            // Extract current rule data
            const conditions = [];
            const conditionGroups = ruleDiv.querySelectorAll('.condition-group');
            conditionGroups.forEach(group => {
                const property = group.querySelector('.condition-property').value;
                const value = group.querySelector('.condition-value').value;
                if (property && value) {
                    conditions.push({ property, value });
                }
            });
            
            const actions = [];
            const actionItems = ruleDiv.querySelectorAll('.action-item');
            actionItems.forEach(item => {
                const property = item.querySelector('.action-property').value;
                const value = item.querySelector('.action-value').value;
                if (property && value) {
                    actions.push({ property, value });
                }
            });
            
            // Create duplicate rule
            if (conditions.length > 0 && actions.length > 0) {
                addRule(conditions, actions);
            } else {
                alert('Cannot duplicate incomplete rule. Please fill in all fields first.');
            }
        }
        
        function exportRules() {
            if (styleRules.length === 0) {
                alert('No rules to export.');
                return;
            }
            
            const dataStr = JSON.stringify(styleRules, null, 2);
            const dataBlob = new Blob([dataStr], {type: 'application/json'});
            
            const link = document.createElement('a');
            link.href = URL.createObjectURL(dataBlob);
            link.download = 'svg-animation-rules.json';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            
            console.log('Exported rules:', window.styleRules);
        }
        
        function importRules(file) {
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const importedRules = JSON.parse(e.target.result);
                    
                    if (!Array.isArray(importedRules)) {
                        throw new Error('Invalid file format: expected an array of rules');
                    }
                    
                    // Validate rule structure
                    const validRules = importedRules.filter(rule => 
                        rule.property && rule.value && rule.targetProperty && rule.targetValue
                    );
                    
                    if (validRules.length === 0) {
                        throw new Error('No valid rules found in file');
                    }
                    
                    // Clear existing rules and load imported ones
                    clearAllRules();
                    
                    validRules.forEach(rule => {
                        addRule(rule.property, rule.value, rule.targetProperty, rule.targetValue);
                    });
                    
                    alert(`Successfully imported ${validRules.length} rule(s).`);
                    console.log('Imported rules:', validRules);
                    
                } catch (error) {
                    alert(`Failed to import rules: ${error.message}`);
                    console.error('Import error:', error);
                }
            };
            
            reader.readAsText(file);
            
            // Reset the file input
            document.getElementById('importFileInput').value = '';
        }
        
        function clearAllRules() {
            window.styleRules = [];
            document.getElementById('rulesList').innerHTML = '';
            saveRulesToStorage();
            
            // Apply empty rules to existing SVG if available
            if (window.svgAnimator) {
                window.svgAnimator.applyStyleRules(window.styleRules);
            }
        }
        
        function removeRule(ruleId) {
            const ruleElement = document.getElementById(ruleId);
            if (ruleElement) {
                // Prevent removal of system rules
                if (ruleElement.dataset.isSystem === 'true') {
                    alert('System rules cannot be removed. You can edit them but not delete them.');
                    return;
                }
                
                ruleElement.remove();
                updateStyleRules();
                saveRulesToStorage();
            }
        }
        
        function showRuleMatches(ruleId) {
            const ruleElement = document.getElementById(ruleId);
            if (!ruleElement || !window.svgAnimator) {
                return;
            }
            
            // Get the rule conditions
            const conditions = [];
            const conditionGroups = ruleElement.querySelectorAll('.condition-group');
            conditionGroups.forEach(group => {
                const property = group.querySelector('.condition-property').value;
                const operator = group.querySelector('.condition-operator')?.value || '=';
                const value = group.querySelector('.condition-value').value.trim();
                if (property && value) {
                    conditions.push({ property, operator, value });
                }
            });
            
            if (conditions.length === 0) {
                alert('This rule has no conditions to match.');
                return;
            }
            
            // Pause any current animation
            if (window.svgAnimator.isAnimating) {
                window.svgAnimator.pauseAnimation();
            }
            
            // Show complete SVG first
            window.svgAnimator.showComplete();
            
            // Find matching elements
            const matchingElements = [];
            window.svgAnimator.allElements.forEach(element => {
                const allConditionsMet = conditions.every(condition => {
                    // Use the same condition checking logic as applyStyleRulesToElement
                    let elementValue = element.getAttribute(condition.property) || element.style[condition.property] || '';
                    
                    // Handle special cases for computed styles and dataset properties
                    if (!elementValue) {
                        const style = window.getComputedStyle(element);
                        if (condition.property === 'stroke-width') {
                            elementValue = style.strokeWidth || '';
                        } else if (condition.property === 'opacity') {
                            elementValue = style.opacity || '';
                        } else if (condition.property === 'path-length') {
                            elementValue = element.dataset.pathLength || '';
                        }
                    }
                    
                    // Normalize values for comparison
                    const normalizedElementValue = elementValue.toString().trim();
                    const normalizedConditionValue = condition.value.toString().trim();
                    const operator = condition.operator || '=';
                    
                    // Handle numeric comparisons for specific properties
                    if (['stroke-width', 'opacity', 'stroke-opacity', 'fill-opacity', 'path-length', 'animation-speed'].includes(condition.property)) {
                        // Remove units (px, em, etc.) and parse as number
                        const elementNum = parseFloat(normalizedElementValue.replace(/[^\d.-]/g, ''));
                        const conditionNum = parseFloat(normalizedConditionValue.replace(/[^\d.-]/g, ''));
                        
                        if (!isNaN(elementNum) && !isNaN(conditionNum)) {
                            switch (operator) {
                                case '=': return Math.abs(elementNum - conditionNum) < 0.001;
                                case '<': return elementNum < conditionNum;
                                case '>': return elementNum > conditionNum;
                                case '<=': return elementNum <= conditionNum;
                                case '>=': return elementNum >= conditionNum;
                                default: return Math.abs(elementNum - conditionNum) < 0.001;
                            }
                        }
                        return false;
                    }
                    
                    // String comparison (only supports equality)
                    return normalizedElementValue === normalizedConditionValue;
                });
                
                if (allConditionsMet) {
                    matchingElements.push(element);
                }
            });
            
            // Highlight matching elements
            if (matchingElements.length > 0) {
                highlightElements(matchingElements);
                console.log(`Rule "${ruleElement.querySelector('.rule-name-input').value}" matches ${matchingElements.length} elements`);
            } else {
                alert('No elements match this rule\'s conditions.');
            }
        }
        
        function highlightElements(elements) {
            // Store original styles
            const originalStyles = new Map();
            
            elements.forEach(element => {
                // Store original styles
                originalStyles.set(element, {
                    stroke: element.style.stroke || element.getAttribute('stroke'),
                    strokeWidth: element.style.strokeWidth || element.getAttribute('stroke-width'),
                    fill: element.style.fill || element.getAttribute('fill'),
                    opacity: element.style.opacity
                });
                
                // Apply highlight styles
                element.style.stroke = '#ff0000';
                element.style.strokeWidth = '3';
                element.style.fill = 'rgba(255, 0, 0, 0.2)';
                element.style.opacity = '1';
            });
            
            // Remove highlights after 3 seconds
            setTimeout(() => {
                elements.forEach(element => {
                    const original = originalStyles.get(element);
                    if (original) {
                        element.style.stroke = original.stroke || '';
                        element.style.strokeWidth = original.strokeWidth || '';
                        element.style.fill = original.fill || '';
                        element.style.opacity = original.opacity || '';
                    }
                });
            }, 3000);
        }
        
        function updateStyleRules() {
            window.styleRules = [];
            const ruleItems = document.querySelectorAll('.rule-item');
            
            ruleItems.forEach(item => {
                const name = item.querySelector('.rule-name-input')?.value || 'Unnamed Rule';
                const isSystem = item.dataset.isSystem === 'true';
                
                const conditions = [];
                const conditionGroups = item.querySelectorAll('.condition-group');
                
                conditionGroups.forEach(group => {
                    const property = group.querySelector('.condition-property').value;
                    const operator = group.querySelector('.condition-operator')?.value || '=';
                    const value = group.querySelector('.condition-value').value.trim();
                    if (property && value) {
                        conditions.push({ property, operator, value });
                    }
                });
                
                const actions = [];
                const actionItems = item.querySelectorAll('.action-item');
                
                actionItems.forEach(actionItem => {
                    const property = actionItem.querySelector('.action-property').value;
                    const value = actionItem.querySelector('.action-value').value.trim();
                    if (property && value) {
                        actions.push({ property, value });
                    }
                });
                
                if (conditions.length > 0 && actions.length > 0) {
                    window.styleRules.push({
                        name,
                        isSystem,
                        conditions,
                        actions
                    });
                }
            });
            
            console.log('Updated style rules:', window.styleRules);
            
            // Save rules to storage
            saveRulesToStorage();
            
            // Apply rules to existing SVG if available
            if (window.svgAnimator) {
                console.log('Re-applying rules to all elements...');
                window.svgAnimator.applyStyleRules(window.styleRules);
                // Recategorize paths when rules change (handwriting detection may have changed)
                window.svgAnimator.recategorizePaths();
                window.svgAnimator.updatePathStats();
                console.log('Rules re-applied successfully');
            }
        }
        
        function applyStyleRulesToElement(element) {
            // Get stroke-width for debugging
            const strokeWidthAttr = element.getAttribute('stroke-width');
            const strokeWidthStyle = element.style.strokeWidth;
            const strokeWidthComputed = window.getComputedStyle(element).strokeWidth;
            
            console.log(`Checking element for rule application:`, {
                tagName: element.tagName,
                isHandwriting: element.dataset.isHandwriting,
                pathLength: element.dataset.pathLength,
                strokeWidthAttr: strokeWidthAttr,
                strokeWidthStyle: strokeWidthStyle,
                strokeWidthComputed: strokeWidthComputed
            });
            
            window.styleRules.forEach(rule => {
                // Check if all conditions are met
                const allConditionsMet = rule.conditions.every(condition => {
                    let elementValue = element.getAttribute(condition.property) || element.style[condition.property] || '';
                    
                    // Handle special cases for computed styles and dataset properties
                    if (!elementValue) {
                        const style = window.getComputedStyle(element);
                        if (condition.property === 'stroke-width') {
                            elementValue = style.strokeWidth || '';
                            console.log(`  Getting stroke-width from computed style: "${elementValue}"`);
                        } else if (condition.property === 'stroke') {
                            elementValue = style.stroke || '';
                            console.log(`  Getting stroke from computed style: "${elementValue}"`);
                        } else if (condition.property === 'opacity') {
                            elementValue = style.opacity || '';
                        } else if (condition.property === 'path-length') {
                            elementValue = element.dataset.pathLength || '';
                        }
                    } else {
                        console.log(`  Found ${condition.property} value directly: "${elementValue}"`);
                    }
                    
                    // Normalize values for comparison
                    const normalizedElementValue = elementValue.toString().trim();
                    const normalizedConditionValue = condition.value.toString().trim();
                    const operator = condition.operator || '=';
                    
                    // Handle numeric comparisons for specific properties
                    if (['stroke-width', 'opacity', 'stroke-opacity', 'fill-opacity', 'path-length', 'animation-speed'].includes(condition.property)) {
                        // Remove units (px, em, etc.) and parse as number
                        const elementNum = parseFloat(normalizedElementValue.replace(/[^\d.-]/g, ''));
                        const conditionNum = parseFloat(normalizedConditionValue.replace(/[^\d.-]/g, ''));
                        
                        if (!isNaN(elementNum) && !isNaN(conditionNum)) {
                            let result = false;
                            switch (operator) {
                                case '=': result = Math.abs(elementNum - conditionNum) < 0.001; break; // Handle floating point precision
                                case '<': result = elementNum < conditionNum; break;
                                case '>': result = elementNum > conditionNum; break;
                                case '<=': result = elementNum <= conditionNum; break;
                                case '>=': result = elementNum >= conditionNum; break;
                                default: result = Math.abs(elementNum - conditionNum) < 0.001; break;
                            }
                            console.log(`  Numeric condition: ${elementNum} ${operator} ${conditionNum} = ${result} (original: "${normalizedElementValue}" vs "${normalizedConditionValue}")`);
                            return result;
                        } else {
                            console.log(`  Failed to parse numeric values: element="${normalizedElementValue}" -> ${elementNum}, condition="${normalizedConditionValue}" -> ${conditionNum}`);
                        }
                    }
                    
                    // String comparison (only supports equality)
                    let result = normalizedElementValue === normalizedConditionValue;
                    
                    // Special handling for color values (stroke, fill)
                    if (!result && (condition.property === 'stroke' || condition.property === 'fill')) {
                        // Try to normalize color values for comparison
                        const normalizeColor = (color) => {
                            if (color === 'black' || color === '#000' || color === '#000000' || 
                                color === 'rgb(0, 0, 0)' || color === 'rgb(0,0,0)') {
                                return '#000000';
                            }
                            if (color.startsWith('rgb(')) {
                                // Convert rgb() to hex if needed
                                const rgbMatch = color.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);
                                if (rgbMatch) {
                                    const r = parseInt(rgbMatch[1]).toString(16).padStart(2, '0');
                                    const g = parseInt(rgbMatch[2]).toString(16).padStart(2, '0');
                                    const b = parseInt(rgbMatch[3]).toString(16).padStart(2, '0');
                                    return `#${r}${g}${b}`;
                                }
                            }
                            return color.toLowerCase();
                        };
                        
                        const normalizedElementColor = normalizeColor(normalizedElementValue);
                        const normalizedConditionColor = normalizeColor(normalizedConditionValue);
                        result = normalizedElementColor === normalizedConditionColor;
                        console.log(`  Color comparison: "${normalizedElementValue}" -> "${normalizedElementColor}" vs "${normalizedConditionValue}" -> "${normalizedConditionColor}" = ${result}`);
                    }
                    
                    console.log(`  String condition: "${normalizedElementValue}" ${operator} "${normalizedConditionValue}" = ${result}`);
                    return result;
                });
                
                // Apply all actions if all conditions are met
                if (allConditionsMet) {
                    const conditionDesc = rule.conditions.map(c => `${c.property}=${c.value}`).join(' AND ');
                    const actionDesc = rule.actions.map(a => `${a.property}=${a.value}`).join(' AND ');
                    console.log(`Applying multi-action rule: ${conditionDesc} -> ${actionDesc}`);
                    
                    rule.actions.forEach(action => {
                        if (action.property === 'stroke-width') {
                            element.style.strokeWidth = action.value;
                        } else if (action.property === 'opacity') {
                            element.style.opacity = action.value;
                        } else if (action.property === 'stroke') {
                            element.style.stroke = action.value;
                        } else if (action.property === 'fill') {
                            element.style.fill = action.value;
                        } else if (action.property === 'stroke-opacity') {
                            element.style.strokeOpacity = action.value;
                        } else if (action.property === 'fill-opacity') {
                            element.style.fillOpacity = action.value;
                        } else if (action.property === 'animation-speed') {
                            element.dataset.animationSpeed = action.value;
                            console.log(`HTML: Set animation speed multiplier ${action.value} on element:`, element);
                        } else if (action.property === 'glow-effect') {
                            // Apply glow effect with specified color and optional size
                            const actionValue = action.value || '#ffd700'; // Default to gold
                            
                            // Parse color and size from value (format: "color" or "color,size")
                            let glowColor = '#ffd700';
                            let glowSize = 8; // Default size
                            
                            if (actionValue.includes(',')) {
                                const parts = actionValue.split(',');
                                glowColor = parts[0].trim();
                                glowSize = parseInt(parts[1].trim()) || 8;
                            } else {
                                glowColor = actionValue;
                            }
                            
                            // Use multiple drop-shadows with configurable size
                            const size1 = Math.round(glowSize * 0.25);
                            const size2 = Math.round(glowSize * 0.5);
                            const size3 = glowSize;
                            const size4 = Math.round(glowSize * 1.5);
                            
                            const filterValue = `drop-shadow(0 0 ${size1}px ${glowColor}) drop-shadow(0 0 ${size2}px ${glowColor}) drop-shadow(0 0 ${size3}px ${glowColor}) drop-shadow(0 0 ${size4}px ${glowColor})`;
                            element.style.filter = filterValue;
                            element.style.webkitFilter = filterValue; // For Safari
                            
                            console.log(`HTML: Applied glow effect with color ${glowColor} and size ${glowSize}px to element:`, element);
                        }
                    });
                }
            });
        }
        
        // Initialize rules UI when page loads
        document.addEventListener('DOMContentLoaded', () => {
            initializeHamburgerMenu();
            initializeRulesUI();
            initializeRecordingControls();
            initializeZoomControls();
            
            // Initialize SVG pan and zoom after SVGAnimator is ready
            setTimeout(() => {
                initializeSVGPanZoom();
                // Initialize drawing tools after SVG pan/zoom is set up
                initializeDrawingTools();
            }, 1500); // Increased delay to ensure SVG is loaded
            
            // Ensure rules are applied after SVGAnimator is initialized
            setTimeout(() => {
                if (window.svgAnimator && window.styleRules.length > 0) {
                    window.svgAnimator.applyStyleRules(window.styleRules);
                    window.svgAnimator.recategorizePaths();
                    window.svgAnimator.updatePathStats();
                }
                
                // Refresh control values from localStorage settings
                if (window.svgAnimator) {
                    window.svgAnimator.refreshControlValues();
                }
            }, 1000);
        });
        
        // Initialize zoom control buttons
        function initializeZoomControls() {
            const zoomInBtn = document.getElementById('zoomInBtn');
            const zoomOutBtn = document.getElementById('zoomOutBtn');
            const zoomFitBtn = document.getElementById('zoomFitBtn');
            const resetViewBtn = document.getElementById('resetViewBtn');
            const zoomLevel = document.getElementById('zoomLevel');
            
            if (zoomInBtn) {
                zoomInBtn.addEventListener('click', () => {
                    if (window.zoomIn) {
                        window.zoomIn();
                        updateZoomIndicator();
                    }
                });
            }
            
            if (zoomOutBtn) {
                zoomOutBtn.addEventListener('click', () => {
                    if (window.zoomOut) {
                        window.zoomOut();
                        updateZoomIndicator();
                    }
                });
            }
            
            if (zoomFitBtn) {
                zoomFitBtn.addEventListener('click', () => {
                    if (window.zoomToFit) {
                        window.zoomToFit();
                        updateZoomIndicator();
                    }
                });
            }
            
            if (resetViewBtn) {
                resetViewBtn.addEventListener('click', () => {
                    if (window.resetSVGView) {
                        window.resetSVGView();
                        updateZoomIndicator();
                    }
                });
            }
            
            function updateZoomIndicator() {
                // We'll need to expose the current scale value
                if (window.getCurrentScale && zoomLevel) {
                    const scale = window.getCurrentScale();
                    zoomLevel.textContent = Math.round(scale * 100) + '%';
                }
            }
            
            // Update indicator initially
            setTimeout(updateZoomIndicator, 100);
        }
        
        // Global SVG variables accessible to both pan/zoom and drawing systems
        let svgElement = null;
        let svgContainer = null;
        let scale = 1;
        let panX = 0;
        let panY = 0;
        let isPanning = false;
        let startPanX = 0;
        let startPanY = 0;
        let startMouseX = 0;
        let startMouseY = 0;
        
        // =====================================
        // Drawing Tools System
        // =====================================
        function initializeDrawingTools() {
            console.log('Initializing drawing tools...');
            let currentMode = 'select'; // 'select' or 'pen'
            let isDrawing = false;
            let currentPath = null;
            let pathData = '';
            let points = []; // Store points for smoothing
            
            // Get SVG element references
            svgElement = document.getElementById('animated-svg');
            svgContainer = document.querySelector('.svg-container');
            
            console.log('Drawing tools - SVG Element:', svgElement);
            console.log('Drawing tools - SVG Container:', svgContainer);
            
            if (!svgElement) {
                console.error('SVG element not found for drawing tools');
                return;
            }
            
            if (!svgContainer) {
                console.error('SVG container not found for drawing tools');
                return;
            }
            
            // Pen management system
            let penConfigs = {};
            let currentPen = 1;
            const PEN_STORAGE_KEY = 'svg-animation-pens';
            
            // Default pen configurations
            const defaultPens = {
                1: { color: '#000000', width: 2, opacity: 1, name: 'Black Pen' },
                2: { color: '#ff0000', width: 3, opacity: 0.8, name: 'Red Pen' },
                3: { color: '#0066cc', width: 5, opacity: 0.6, name: 'Blue Pen' }
            };
            
            function loadPensFromStorage() {
                try {
                    const stored = localStorage.getItem(PEN_STORAGE_KEY);
                    if (stored) {
                        penConfigs = JSON.parse(stored);
                        console.log('Loaded pens from storage:', penConfigs);
                        return penConfigs;
                    }
                } catch (error) {
                    console.warn('Failed to load pens from storage:', error);
                }
                
                // Use defaults if no storage or error
                penConfigs = { ...defaultPens };
                return penConfigs;
            }
            
            function savePensToStorage() {
                try {
                    localStorage.setItem(PEN_STORAGE_KEY, JSON.stringify(penConfigs));
                    console.log('Saved pens to storage:', penConfigs);
                } catch (error) {
                    console.warn('Failed to save pens to storage:', error);
                }
            }
            
            function addPen() {
                const newPenId = Math.max(...Object.keys(penConfigs).map(Number)) + 1;
                const newPen = {
                    color: '#000000',
                    width: 2,
                    opacity: 1,
                    name: `Pen ${newPenId}`
                };
                
                penConfigs[newPenId] = newPen;
                renderPenConfigs();
                savePensToStorage();
                
                console.log('Added new pen:', newPenId, newPen);
                return newPenId;
            }
            
            function removePen(penId) {
                if (Object.keys(penConfigs).length <= 1) {
                    alert('Cannot remove the last pen. At least one pen must remain.');
                    return;
                }
                
                const penIdNum = parseInt(penId);
                if (penConfigs[penIdNum]) {
                    delete penConfigs[penIdNum];
                    
                    // If we deleted the current pen, switch to the first available pen
                    if (currentPen === penIdNum) {
                        currentPen = parseInt(Object.keys(penConfigs)[0]);
                        updatePenModeDisplay();
                    }
                    
                    renderPenConfigs();
                    savePensToStorage();
                    console.log('Removed pen:', penId);
                }
            }
            
            function updatePenConfig(penId, property, value) {
                const penIdNum = parseInt(penId);
                if (penConfigs[penIdNum]) {
                    penConfigs[penIdNum][property] = value;
                    savePensToStorage();
                    updatePenIndicator(); // Update visual indicator when pen changes
                }
            }
            
            function updatePenModeDisplay() {
                const penModeText = document.getElementById('penModeText');
                if (penModeText && penConfigs[currentPen]) {
                    penModeText.textContent = penConfigs[currentPen].name || `Pen ${currentPen}`;
                }
                updatePenIndicator();
            }
            
            function updatePenIndicator() {
                const penIndicator = document.getElementById('penIndicator');
                if (penIndicator && penConfigs[currentPen]) {
                    const config = penConfigs[currentPen];
                    penIndicator.style.backgroundColor = config.color;
                    penIndicator.style.width = `${Math.min(config.width * 2, 20)}px`;
                    penIndicator.style.height = `${Math.min(config.width * 2, 20)}px`;
                    penIndicator.style.opacity = config.opacity;
                    penIndicator.title = `${config.name}: ${config.color}, ${config.width}px, ${Math.round(config.opacity * 100)}%`;
                }
            }
            
            // Load pens on startup
            loadPensFromStorage();
            
            function renderPenConfigs() {
                const pensContainer = document.querySelector('.pen-configs');
                if (!pensContainer) return;
                
                pensContainer.innerHTML = '';
                
                Object.keys(penConfigs).sort((a, b) => Number(a) - Number(b)).forEach(penId => {
                    const config = penConfigs[penId];
                    const penDiv = document.createElement('div');
                    penDiv.className = 'pen-config';
                    penDiv.dataset.pen = penId;
                    
                    penDiv.innerHTML = `
                        <div class="pen-config-header">
                            <input type="text" class="pen-name-input" value="${config.name || `Pen ${penId}`}" placeholder="Pen name" data-pen="${penId}">
                            <button class="remove-pen-btn" onclick="removePen('${penId}')">√ó</button>
                        </div>
                        <div class="pen-controls">
                            <div class="pen-control-row">
                                <label>Color:</label>
                                <input type="color" id="pen${penId}Color" value="${config.color}">
                            </div>
                            <div class="pen-control-row">
                                <label>Width:</label>
                                <input type="range" id="pen${penId}Width" min="1" max="20" value="${config.width}" step="0.5">
                                <span class="width-value">${config.width}px</span>
                            </div>
                            <div class="pen-control-row">
                                <label>Opacity:</label>
                                <input type="range" id="pen${penId}Opacity" min="0" max="1" value="${config.opacity}" step="0.1">
                                <span class="opacity-value">${Math.round(config.opacity * 100)}%</span>
                            </div>
                        </div>
                    `;
                    
                    pensContainer.appendChild(penDiv);
                    
                    // Add event listeners for this pen
                    const colorInput = document.getElementById(`pen${penId}Color`);
                    const widthInput = document.getElementById(`pen${penId}Width`);
                    const opacityInput = document.getElementById(`pen${penId}Opacity`);
                    const widthValue = penDiv.querySelector('.width-value');
                    const opacityValue = penDiv.querySelector('.opacity-value');
                    const nameInput = penDiv.querySelector('.pen-name-input');
                    
                    colorInput.addEventListener('change', (e) => {
                        updatePenConfig(penId, 'color', e.target.value);
                    });
                    
                    widthInput.addEventListener('input', (e) => {
                        updatePenConfig(penId, 'width', parseFloat(e.target.value));
                        widthValue.textContent = e.target.value + 'px';
                    });
                    
                    opacityInput.addEventListener('input', (e) => {
                        updatePenConfig(penId, 'opacity', parseFloat(e.target.value));
                        opacityValue.textContent = Math.round(e.target.value * 100) + '%';
                    });
                    
                    nameInput.addEventListener('input', (e) => {
                        const newName = e.target.value.trim();
                        if (newName) {
                            updatePenConfig(penId, 'name', newName);
                            updatePenModeDisplay(); // Update button if this is current pen
                        }
                    });
                    
                    nameInput.addEventListener('blur', (e) => {
                        const newName = e.target.value.trim();
                        if (newName) {
                            updatePenConfig(penId, 'name', newName);
                            updatePenModeDisplay(); // Update button if this is current pen
                        }
                    });
                });
                
                // Add the "Add Pen" button at the bottom
                const addPenBtn = document.createElement('button');
                addPenBtn.className = 'add-pen-btn';
                addPenBtn.textContent = '+ Add Pen';
                addPenBtn.onclick = addPen;
                pensContainer.appendChild(addPenBtn);
            }
            
            // Mode switching
            const selectModeBtn = document.getElementById('selectModeBtn');
            const penModeBtn = document.getElementById('penModeBtn');
            const penModeText = document.getElementById('penModeText');
            
            console.log('Drawing tools buttons found:');
            console.log('- selectModeBtn:', selectModeBtn);
            console.log('- penModeBtn:', penModeBtn);
            console.log('- penModeText:', penModeText);
            
            if (!selectModeBtn || !penModeBtn || !penModeText) {
                console.error('Some drawing tools buttons not found!');
                return;
            }
            
            function setMode(mode) {
                console.log('Setting mode to:', mode);
                currentMode = mode;
                
                if (mode === 'select') {
                    selectModeBtn.classList.add('active');
                    penModeBtn.classList.remove('active');
                    if (!isPanning) {
                        svgContainer.style.cursor = 'grab';
                    }
                } else if (mode === 'pen') {
                    selectModeBtn.classList.remove('active');
                    penModeBtn.classList.add('active');
                    svgContainer.style.cursor = 'crosshair';
                }
                console.log('Mode set to:', currentMode);
            }
            
            selectModeBtn.addEventListener('click', () => setMode('select'));
            
            penModeBtn.addEventListener('click', () => {
                console.log('Pen button clicked, current mode:', currentMode);
                if (currentMode === 'pen') {
                    // Cycle to next pen
                    const penIds = Object.keys(penConfigs).map(Number).sort((a, b) => a - b);
                    const currentIndex = penIds.indexOf(currentPen);
                    const nextIndex = (currentIndex + 1) % penIds.length;
                    currentPen = penIds[nextIndex];
                    updatePenModeDisplay();
                    console.log('Switched to pen', currentPen);
                } else {
                    // Switch to pen mode
                    setMode('pen');
                    updatePenModeDisplay();
                    console.log('Switched to pen mode with pen', currentPen);
                }
            });
            
            // Initialize pen configurations UI
            renderPenConfigs();
            
            // Initialize pen mode display and indicator
            updatePenModeDisplay();
            
            // Improved smooth path function for better handwriting continuity
            function createSmoothPath(points) {
                if (points.length < 2) return '';
                if (points.length === 2) {
                    return `M ${points[0].x} ${points[0].y} L ${points[1].x} ${points[1].y}`;
                }
                if (points.length === 3) {
                    return `M ${points[0].x} ${points[0].y} Q ${points[1].x} ${points[1].y} ${points[2].x} ${points[2].y}`;
                }
                
                let path = `M ${points[0].x} ${points[0].y}`;
                
                // Use continuous quadratic curves for smooth, flowing handwriting
                for (let i = 1; i < points.length - 1; i++) {
                    const curr = points[i];
                    const next = points[i + 1];
                    
                    // Calculate smooth control point for continuous curves
                    const controlX = curr.x;
                    const controlY = curr.y;
                    const endX = (curr.x + next.x) / 2;
                    const endY = (curr.y + next.y) / 2;
                    
                    path += ` Q ${controlX} ${controlY} ${endX} ${endY}`;
                }
                
                // Always end with the final point to ensure complete drawing
                const lastPoint = points[points.length - 1];
                path += ` T ${lastPoint.x} ${lastPoint.y}`;
                
                return path;
            }
            
            // Drawing functionality
            function startDrawing(e) {
                if (currentMode !== 'pen') return;
                
                console.log('=== STARTING DRAWING ===');
                e.preventDefault();
                e.stopPropagation();
                
                isDrawing = true;
                points = []; // Reset points array
                
                // Get SVG viewBox to calculate proper coordinates
                const viewBox = svgElement.getAttribute('viewBox');
                const [viewBoxX, viewBoxY, viewBoxWidth, viewBoxHeight] = viewBox ? 
                    viewBox.split(' ').map(Number) : [0, 0, 100, 100];
                
                // Get coordinates relative to SVG element specifically
                const svgRect = svgElement.getBoundingClientRect();
                const relativeX = e.clientX - svgRect.left;
                const relativeY = e.clientY - svgRect.top;
                
                // Convert to SVG coordinate system without clamping
                const svgX = viewBoxX + (relativeX / svgRect.width) * viewBoxWidth;
                const svgY = viewBoxY + (relativeY / svgRect.height) * viewBoxHeight;
                
                // Use unclamped coordinates for free drawing
                const finalX = svgX;
                const finalY = svgY;
                
                // Add first point
                points.push({x: finalX, y: finalY});
                
                // Create new path element
                currentPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                currentPath.setAttribute('fill', 'none');
                currentPath.setAttribute('stroke', penConfigs[currentPen].color);
                currentPath.setAttribute('stroke-width', penConfigs[currentPen].width);
                currentPath.setAttribute('stroke-opacity', penConfigs[currentPen].opacity);
                currentPath.setAttribute('stroke-linecap', 'round');
                currentPath.setAttribute('stroke-linejoin', 'round');
                currentPath.setAttribute('class', 'drawn-path'); // Keep visible after drawing
                
                // Start path data
                pathData = `M ${finalX.toFixed(2)} ${finalY.toFixed(2)}`;
                currentPath.setAttribute('d', pathData);
                
                // Add to SVG
                svgElement.appendChild(currentPath);
                console.log('Started drawing at coords:', finalX.toFixed(2), finalY.toFixed(2));
            }
            
            function continueDrawing(e) {
                if (!isDrawing || currentMode !== 'pen' || !currentPath) return;
                
                e.preventDefault();
                e.stopPropagation();
                
                // Get SVG viewBox for coordinate conversion
                const viewBox = svgElement.getAttribute('viewBox');
                const [viewBoxX, viewBoxY, viewBoxWidth, viewBoxHeight] = viewBox ? 
                    viewBox.split(' ').map(Number) : [0, 0, 100, 100];
                
                // Get coordinates relative to SVG
                const svgRect = svgElement.getBoundingClientRect();
                const relativeX = e.clientX - svgRect.left;
                const relativeY = e.clientY - svgRect.top;
                
                // Convert to SVG coordinate system without clamping
                const svgX = viewBoxX + (relativeX / svgRect.width) * viewBoxWidth;
                const svgY = viewBoxY + (relativeY / svgRect.height) * viewBoxHeight;
                
                // Use unclamped coordinates for free drawing
                const newPoint = {x: svgX, y: svgY};
                let shouldAddPoint = true;
                
                if (points.length > 0) {
                    const lastPoint = points[points.length - 1];
                    const distance = Math.sqrt(Math.pow(newPoint.x - lastPoint.x, 2) + Math.pow(newPoint.y - lastPoint.y, 2));
                    
                    // Reduce minimum distance to maintain fluidity
                    if (distance < 4) {
                        shouldAddPoint = false;
                    }
                }
                
                // Add point and update path more frequently for continuous flow
                if (shouldAddPoint) {
                    points.push(newPoint);
                    
                    // Update path every time for continuous drawing feel
                    const smoothPath = createSmoothPath(points);
                    currentPath.setAttribute('d', smoothPath);
                }
            }
            
            function stopDrawing(e) {
                if (!isDrawing || currentMode !== 'pen') return;
                
                isDrawing = false;
                console.log('=== STOPPING DRAWING ===');
                
                if (currentPath && points.length > 2) {
                    // Generate final smooth path
                    const finalPath = createSmoothPath(points);
                    currentPath.setAttribute('d', finalPath);
                    
                    // Keep drawn-path class to remain visible
                    // (will be removed when animation resets)
                    
                    // Generate unique ID for the path
                    const pathId = 'drawn-path-' + Date.now();
                    currentPath.setAttribute('id', pathId);
                    console.log('Kept smooth path with ID:', pathId);
                    
                    // Expand SVG viewBox if needed to include the new drawing
                    expandViewBoxToIncludePath(currentPath);
                    
                    // Add the new path to the SVG animator's tracking
                    if (window.svgAnimator) {
                        // Set up animation properties like other paths
                        const pathLength = currentPath.getTotalLength();
                        const strokeColor = currentPath.getAttribute('stroke') || '#000000';
                        
                        // Set up for animation (CSS will override for drawn-path visibility)
                        currentPath.style.strokeDasharray = pathLength;
                        currentPath.style.transition = 'none';
                        currentPath.dataset.pathLength = pathLength;
                        currentPath.dataset.strokeColor = strokeColor;
                        currentPath.dataset.elementType = 'path';
                        currentPath.dataset.isHandwriting = 'true';
                        
                        // Get the next element index
                        const nextIndex = window.svgAnimator.allElements.length;
                        currentPath.dataset.elementIndex = nextIndex;
                        
                        // Add click handler for path editor selection
                        currentPath.addEventListener('click', (e) => {
                            e.stopPropagation();
                            window.svgAnimator.selectElementInPathEditor(nextIndex);
                        });
                        
                        // Add to allElements array for path editor
                        window.svgAnimator.allElements.push(currentPath);
                        
                        // Add to paths array for animation system
                        window.svgAnimator.paths.push(currentPath);
                        
                        // Categorize the path as handwriting
                        window.svgAnimator.handwritingPaths.push(currentPath);
                        
                        // Update the sorted paths array
                        window.svgAnimator.sortedPaths = [...window.svgAnimator.allElements];
                        
                        // Update stats and refresh path editor if visible
                        window.svgAnimator.updatePathStats();
                        if (window.svgAnimator.pathEditorVisible) {
                            window.svgAnimator.refreshPathList();
                        }
                    }
                } else if (currentPath) {
                    console.log('Removed short path');
                    currentPath.remove();
                }
                
                currentPath = null;
                points = [];
            }
            
            // Function to expand SVG viewBox to include new drawn content
            function expandViewBoxToIncludePath(path) {
                if (!path) return;
                
                try {
                    const bbox = path.getBBox();
                    const currentViewBox = svgElement.getAttribute('viewBox');
                    let [vbX, vbY, vbWidth, vbHeight] = currentViewBox ? 
                        currentViewBox.split(' ').map(Number) : [0, 0, 100, 100];
                    
                    // Calculate required viewBox expansion
                    const margin = 50; // Add some margin around new content
                    const minX = Math.min(vbX, bbox.x - margin);
                    const minY = Math.min(vbY, bbox.y - margin);
                    const maxX = Math.max(vbX + vbWidth, bbox.x + bbox.width + margin);
                    const maxY = Math.max(vbY + vbHeight, bbox.y + bbox.height + margin);
                    
                    const newWidth = maxX - minX;
                    const newHeight = maxY - minY;
                    
                    // Only update if the viewBox actually needs to expand
                    if (minX < vbX || minY < vbY || newWidth > vbWidth || newHeight > vbHeight) {
                        const newViewBox = `${minX} ${minY} ${newWidth} ${newHeight}`;
                        svgElement.setAttribute('viewBox', newViewBox);
                        console.log('Expanded viewBox to:', newViewBox);
                    }
                } catch (error) {
                    console.warn('Could not expand viewBox:', error);
                }
            }
            
            // Touch events for tablet support
            svgContainer.addEventListener('touchstart', (e) => {
                if (currentMode === 'pen' && e.touches.length === 1) {
                    const touch = e.touches[0];
                    const mouseEvent = new MouseEvent('mousedown', {
                        clientX: touch.clientX,
                        clientY: touch.clientY
                    });
                    startDrawing(mouseEvent);
                }
            });
            
            svgContainer.addEventListener('touchmove', (e) => {
                if (currentMode === 'pen' && e.touches.length === 1) {
                    const touch = e.touches[0];
                    const mouseEvent = new MouseEvent('mousemove', {
                        clientX: touch.clientX,
                        clientY: touch.clientY
                    });
                    continueDrawing(mouseEvent);
                }
            });
            
            svgContainer.addEventListener('touchend', (e) => {
                if (currentMode === 'pen') {
                    stopDrawing(e);
                }
            });
            
            // Pointer events for stylus support
            if (window.PointerEvent) {
                svgContainer.addEventListener('pointerdown', (e) => {
                    if (currentMode === 'pen' && e.pointerType === 'pen') {
                        startDrawing(e);
                    }
                });
                
                svgContainer.addEventListener('pointermove', (e) => {
                    if (currentMode === 'pen' && e.pointerType === 'pen') {
                        continueDrawing(e);
                    }
                });
                
                svgContainer.addEventListener('pointerup', (e) => {
                    if (currentMode === 'pen' && e.pointerType === 'pen') {
                        stopDrawing(e);
                    }
                });
            }
            
            // Expose drawing functions globally so they can be called from pan/zoom handlers
            window.drawingTools = {
                currentMode: () => currentMode,
                startDrawing,
                continueDrawing,
                stopDrawing,
                setMode
            };
            
            console.log('Drawing tools exposed globally:', window.drawingTools);
            
            // Initialize in select mode
            setMode('select');
            console.log('Drawing tools initialization completed');
        }
        
        // SVG Pan and Zoom functionality
        function initializeSVGPanZoom() {
            console.log('Initializing SVG pan and zoom...');
            
            // Use global variables
            svgContainer = document.querySelector('.svg-container');
            svgElement = document.getElementById('animated-svg');
            
            console.log('SVG Container:', svgContainer);
            console.log('SVG Element:', svgElement);
            
            if (!svgContainer) {
                console.warn('SVG container not found, retrying in 500ms...');
                setTimeout(initializeSVGPanZoom, 500);
                return;
            }
            
            if (!svgElement) {
                console.warn('SVG element not found, retrying in 500ms...');
                setTimeout(initializeSVGPanZoom, 500);
                return;
            }
            
            console.log('Both elements found, setting up pan and zoom...');
            
            // Apply transform to SVG
            function updateTransform() {
                const transform = `translate(${panX}px, ${panY}px) scale(${scale})`;
                svgElement.style.transform = transform;
                svgElement.style.transformOrigin = '0 0'; // Set origin to top-left
                console.log('Transform applied:', transform);
                
                // Update zoom indicator if it exists
                const zoomLevel = document.getElementById('zoomLevel');
                if (zoomLevel) {
                    zoomLevel.textContent = Math.round(scale * 100) + '%';
                }
            }
            
            // Expose current scale for external use
            window.getCurrentScale = () => scale;
            
            // Test the transform immediately
            console.log('Testing initial transform...');
            updateTransform();
            console.log('Testing initial transform...');
            updateTransform();
            
            // Mouse wheel zoom
            svgContainer.addEventListener('wheel', (e) => {
                e.preventDefault();
                
                // Get mouse position relative to the SVG element itself, not the container
                const svgRect = svgElement.getBoundingClientRect();
                const mouseX = e.clientX - svgRect.left;
                const mouseY = e.clientY - svgRect.top;
                
                // Store the current scale before changing it
                const oldScale = scale;
                
                // Update scale
                const zoomSpeed = 0.15;
                const deltaY = e.deltaY;
                
                if (deltaY < 0) {
                    scale = Math.min(scale * (1 + zoomSpeed), 5); // Max zoom 5x
                } else {
                    scale = Math.max(scale * (1 - zoomSpeed), 0.1); // Min zoom 0.1x
                }
                
                // Calculate the scale factor
                const scaleFactor = scale / oldScale;
                
                // Adjust pan to keep the mouse point fixed
                // The formula: new_pan = mouse_pos - scale_factor * (mouse_pos - old_pan)
                panX = mouseX - scaleFactor * (mouseX - panX);
                panY = mouseY - scaleFactor * (mouseY - panY);
                
                updateTransform();
            });
            
            // Simplified mouse pan (drag) - start with basic functionality
            svgContainer.addEventListener('mousedown', (e) => {
                console.log('Mouse down on:', e.target, 'button:', e.button);
                console.log('Drawing tools mode:', window.drawingTools ? window.drawingTools.currentMode() : 'undefined');
                
                // Handle drawing mode first
                if (window.drawingTools && window.drawingTools.currentMode() === 'pen') {
                    console.log('Detected pen mode, calling startDrawing');
                    window.drawingTools.startDrawing(e);
                    return;
                }
                
                // For select mode, allow panning with left mouse button
                if (e.button === 0 && (!window.drawingTools || window.drawingTools.currentMode() === 'select')) { // Left mouse button
                    console.log('Starting pan mode');
                    isPanning = true;
                    startPanX = panX;
                    startPanY = panY;
                    startMouseX = e.clientX;
                    startMouseY = e.clientY;
                    
                    // Set cursor on the container, not the document
                    svgContainer.style.cursor = 'grabbing';
                    console.log('Started panning from:', startMouseX, startMouseY);
                    e.preventDefault();
                }
            });
            
            // Use document-level mousemove to track movement even outside container
            document.addEventListener('mousemove', (e) => {
                // Handle drawing mode
                if (window.drawingTools && window.drawingTools.currentMode() === 'pen') {
                    window.drawingTools.continueDrawing(e);
                    return;
                }
                
                // Handle panning in select mode
                if (isPanning && (!window.drawingTools || window.drawingTools.currentMode() === 'select')) {
                    const deltaX = e.clientX - startMouseX;
                    const deltaY = e.clientY - startMouseY;
                    
                    panX = startPanX + deltaX;
                    panY = startPanY + deltaY;
                    
                    console.log('Panning to:', panX, panY);
                    updateTransform();
                    e.preventDefault();
                }
            });
            
            // Handle mouse up on document to catch releases outside container
            document.addEventListener('mouseup', (e) => {
                // Handle drawing mode
                if (window.drawingTools && window.drawingTools.currentMode() === 'pen') {
                    window.drawingTools.stopDrawing(e);
                    return;
                }
                
                // Handle panning in select mode
                if (isPanning && (!window.drawingTools || window.drawingTools.currentMode() === 'select')) {
                    console.log('Stopped panning');
                    isPanning = false;
                    const currentMode = window.drawingTools ? window.drawingTools.currentMode() : 'select';
                    svgContainer.style.cursor = currentMode === 'select' ? 'grab' : 'crosshair';
                }
            });
            
            // Handle mouse enter/leave for cursor management
            svgContainer.addEventListener('mouseenter', (e) => {
                if (!isPanning) {
                    const currentMode = window.drawingTools ? window.drawingTools.currentMode() : 'select';
                    if (currentMode === 'select') {
                        svgContainer.style.cursor = 'grab';
                    } else if (currentMode === 'pen') {
                        svgContainer.style.cursor = 'crosshair';
                    }
                }
            });
            
            svgContainer.addEventListener('mouseleave', (e) => {
                if (!isPanning) {
                    svgContainer.style.cursor = 'default';
                }
            });
            
            // Double-click to reset view (only in select mode)
            svgContainer.addEventListener('dblclick', (e) => {
                const currentMode = window.drawingTools ? window.drawingTools.currentMode() : 'select';
                if (currentMode === 'select') {
                    console.log('Double-click reset');
                    scale = 1;
                    panX = 0;
                    panY = 0;
                    updateTransform();
                    e.preventDefault();
                }
            });
            
            // Expose zoom/pan functions globally for controls
            window.resetSVGView = () => {
                console.log('Manual reset called');
                scale = 1;
                panX = 0;
                panY = 0;
                updateTransform();
            };
            
            window.zoomIn = () => {
                const centerX = svgContainer.clientWidth / 2;
                const centerY = svgContainer.clientHeight / 2;
                const pointInSVGX = (centerX - panX) / scale;
                const pointInSVGY = (centerY - panY) / scale;
                
                scale = Math.min(scale * 1.2, 5);
                panX = centerX - pointInSVGX * scale;
                panY = centerY - pointInSVGY * scale;
                updateTransform();
            };
            
            window.zoomOut = () => {
                const centerX = svgContainer.clientWidth / 2;
                const centerY = svgContainer.clientHeight / 2;
                const pointInSVGX = (centerX - panX) / scale;
                const pointInSVGY = (centerY - panY) / scale;
                
                scale = Math.max(scale / 1.2, 0.1);
                panX = centerX - pointInSVGX * scale;
                panY = centerY - pointInSVGY * scale;
                updateTransform();
            };
            
            window.zoomToFit = () => {
                if (!svgElement) return;
                
                // Get SVG viewBox or use width/height
                const viewBox = svgElement.viewBox.baseVal;
                const svgWidth = viewBox.width || parseFloat(svgElement.getAttribute('width')) || 800;
                const svgHeight = viewBox.height || parseFloat(svgElement.getAttribute('height')) || 600;
                
                const containerWidth = svgContainer.clientWidth;
                const containerHeight = svgContainer.clientHeight;
                
                // Calculate scale to fit with some padding
                const scaleX = (containerWidth * 0.9) / svgWidth;
                const scaleY = (containerHeight * 0.9) / svgHeight;
                scale = Math.min(scaleX, scaleY, 5); // Don't exceed max zoom
                
                // Center the SVG
                panX = (containerWidth - svgWidth * scale) / 2;
                panY = (containerHeight - svgHeight * scale) / 2;
                
                updateTransform();
            };
            
            console.log('SVG pan and zoom initialization complete');
        }
        
        function initializeRecordingControls() {
            // Validate the end pause number input
            const endPauseValue = document.getElementById('recordEndPauseValue');
            
            endPauseValue.addEventListener('input', (e) => {
                const value = Math.max(0, Math.min(3000, parseInt(e.target.value) || 0));
                e.target.value = value;
            });
            
            // No additional setup needed for checkbox - it works automatically
        }
    </script>
</body>
</html>